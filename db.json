{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/apollo/source/favicon.png","path":"favicon.png","modified":0,"renderable":1},{"_id":"source/images/mysql_layer.png","path":"images/mysql_layer.png","modified":0,"renderable":0},{"_id":"themes/apollo/source/css/apollo.css","path":"css/apollo.css","modified":0,"renderable":1},{"_id":"themes/apollo/source/scss/apollo.scss","path":"scss/apollo.scss","modified":0,"renderable":1},{"_id":"themes/apollo/source/font/sourcesanspro.woff","path":"font/sourcesanspro.woff","modified":0,"renderable":1},{"_id":"themes/apollo/source/font/sourcesanspro.woff2","path":"font/sourcesanspro.woff2","modified":0,"renderable":1}],"Cache":[{"_id":"themes/apollo/.gitignore","hash":"a006beea0877a0aa3610ee00e73f62cb1d45125b","modified":1517036866000},{"_id":"themes/apollo/LICENSE","hash":"6e31ac9076bfc8f09ae47977419eee4edfb63e5b","modified":1517036866000},{"_id":"themes/apollo/README.md","hash":"201c76d030a98578ed5a6ad5c766a7bde91c32d3","modified":1517036866000},{"_id":"themes/apollo/_config.yml","hash":"0a457e5b5bf045d50b7dd793b49be7376f1a7f13","modified":1517036866000},{"_id":"themes/apollo/gulpfile.js","hash":"857a026b6643a2cd52c65d4ae0dc7fe9618206ee","modified":1517036866000},{"_id":"themes/apollo/package.json","hash":"eb1e76ec0b7ed6c6c7b2bd32b4f1e1bbe15800ca","modified":1517036866000},{"_id":"source/_posts/concurrency-notes.md","hash":"b1e3be3b3c1439ad90003a5a732934448e95e358","modified":1518860124967},{"_id":"themes/apollo/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1517036866000},{"_id":"source/_posts/mysql_notes_1.md","hash":"adbda3ce97c2d9c24378e8d9200a6082b6eab936","modified":1517503583669},{"_id":"source/_posts/vim-operator-pending-md.md","hash":"bcf2ec8cc0b9c003fbb1c8f7eda1536c7c7db4cf","modified":1517844418223},{"_id":"themes/apollo/.git/config","hash":"4eba8e6ddc5a8da6c66aa99763c7831c5ddcee6f","modified":1517036866000},{"_id":"themes/apollo/.git/index","hash":"7a8adcb789299516cf9cb50cd18cff8ea717f1d3","modified":1517414330980},{"_id":"themes/apollo/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1517036864000},{"_id":"themes/apollo/.git/packed-refs","hash":"b00506c518854ee36fe9c9f20553f43ad9bc9a51","modified":1517036866000},{"_id":"themes/apollo/doc/doc-en.md","hash":"409e931a444c02a57b64a0a44dde6e66c1881ca0","modified":1517036866000},{"_id":"themes/apollo/doc/doc-zh.md","hash":"2a6a81840cdaf497969268a12d8f62c98cc38103","modified":1517036866000},{"_id":"themes/apollo/languages/en.yml","hash":"40292f2a48e4e6361132033a47c516cb33127b6c","modified":1517036866000},{"_id":"themes/apollo/layout/archive.jade","hash":"62797414355bf4474092bc3a32726c8340820ffb","modified":1517036866000},{"_id":"themes/apollo/languages/zh-cn.yml","hash":"9e4b03e14c094000257ea254fd660dde4c7af63c","modified":1517036866000},{"_id":"themes/apollo/layout/index.jade","hash":"55f2f1b4b5364a0e09cb18e1112664c6415fb881","modified":1517036866000},{"_id":"themes/apollo/layout/post.jade","hash":"245c26244c075c3632d1545c3b228ee9d112f15d","modified":1517036866000},{"_id":"themes/apollo/source/favicon.png","hash":"a9cdcb22d1e74d5480323e19d1983de5a6873b8c","modified":1517036866000},{"_id":"themes/apollo/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1517036864000},{"_id":"themes/apollo/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1517036864000},{"_id":"themes/apollo/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1517036864000},{"_id":"themes/apollo/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1517036864000},{"_id":"themes/apollo/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1517036864000},{"_id":"themes/apollo/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1517036864000},{"_id":"themes/apollo/.git/hooks/pre-rebase.sample","hash":"288efdc0027db4cfd8b7c47c4aeddba09b6ded12","modified":1517036864000},{"_id":"themes/apollo/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1517036864000},{"_id":"source/images/mysql_layer.png","hash":"a430c15c6fea755c31aeeb4092867e594efbd472","modified":1517498062588},{"_id":"themes/apollo/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1517036864000},{"_id":"themes/apollo/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1517036864000},{"_id":"themes/apollo/.git/hooks/prepare-commit-msg.sample","hash":"2584806ba147152ae005cb675aa4f01d5d068456","modified":1517036864000},{"_id":"themes/apollo/.git/logs/HEAD","hash":"cc7af1c7286831ba5897a284cc8ea633e2a89ee1","modified":1517036866000},{"_id":"themes/apollo/layout/mixins/paginator.jade","hash":"f4ee2fb61a32e199b48cf93771749edc8a007391","modified":1517036866000},{"_id":"themes/apollo/layout/mixins/post.jade","hash":"cd9447e9b0ad22213e6a17d9a9b948f9f998f921","modified":1517036866000},{"_id":"themes/apollo/layout/partial/comment.jade","hash":"ff0a2c269c2434da2ac5529872f1d6184a71f96d","modified":1517036866000},{"_id":"themes/apollo/layout/partial/copyright.jade","hash":"217f8b17054e5079f2d30bb7e2e4e36c0f2161b7","modified":1517036866000},{"_id":"themes/apollo/layout/partial/head.jade","hash":"43d2db73f0247a9a3ed00ecb95b537a872b7201a","modified":1517036866000},{"_id":"themes/apollo/layout/partial/nav.jade","hash":"f4842d9d3d763fbb823d112a6f49f24cc42a0ad4","modified":1517036866000},{"_id":"themes/apollo/layout/partial/layout.jade","hash":"529c2ec06cfbc3d5b6d66dd320db50dfab5577a6","modified":1517036866000},{"_id":"themes/apollo/source/css/apollo.css","hash":"e07a11a5da5fc097f023e06a85575356066afd09","modified":1517036866000},{"_id":"themes/apollo/layout/partial/scripts.jade","hash":"6bff591ae3d1ff6750f239c4c933ad61f009f36a","modified":1517036866000},{"_id":"themes/apollo/source/scss/apollo.scss","hash":"e0092f469264b55b25e0d441274f1c812147e7d1","modified":1517036866000},{"_id":"themes/apollo/source/font/sourcesanspro.woff","hash":"a6722c9b6439b7a020a9be3d3178970757a9265c","modified":1517036866000},{"_id":"themes/apollo/source/font/sourcesanspro.woff2","hash":"da65f527a8da65d5eb6721626d28cfdb46ab104a","modified":1517036866000},{"_id":"themes/apollo/.git/objects/pack/pack-d4037f7bd0574dc47f0bcf9f58fc3fc03ef440d5.idx","hash":"90a8e6d1fc043edf7bb69b264419ea25766eb1c7","modified":1517036866000},{"_id":"themes/apollo/.git/refs/heads/master","hash":"e1ff663b08979644efba5f9911db684e916041b3","modified":1517036866000},{"_id":"themes/apollo/source/scss/_partial/archive-post-list.scss","hash":"d2f740a7d48349b7536777c795f82ab740836d0f","modified":1517036866000},{"_id":"themes/apollo/source/scss/_partial/base.scss","hash":"ae967b2049ecb9b8c4e139ecce32fd9fb5358ac5","modified":1517036866000},{"_id":"themes/apollo/source/scss/_partial/footer.scss","hash":"094aca6e52f11b139ac7980ca03fa7b9d8fc7b2f","modified":1517036866000},{"_id":"themes/apollo/source/scss/_partial/copyright.scss","hash":"1309667e3000037170cfbb5b8c9c65f4ffcf6814","modified":1517036866000},{"_id":"themes/apollo/source/scss/_partial/header.scss","hash":"153bde88bf8ffeae4ffd813d8cc694dd83d33d94","modified":1517036866000},{"_id":"themes/apollo/source/scss/_partial/home-post-list.scss","hash":"6b5c59f3d2295944f934aee2c1156012a3306d5d","modified":1517036866000},{"_id":"themes/apollo/source/scss/_partial/normalize.scss","hash":"fd0b27bed6f103ea95b08f698ea663ff576dbcf1","modified":1517036866000},{"_id":"themes/apollo/source/scss/_partial/mq.scss","hash":"fc5dda52cfbb10e27e2471e03f4606fb3d588225","modified":1517036866000},{"_id":"themes/apollo/source/scss/_partial/post.scss","hash":"1998f207541a2590a5624549f96c5e65d136690a","modified":1517036866000},{"_id":"themes/apollo/.git/logs/refs/heads/master","hash":"cc7af1c7286831ba5897a284cc8ea633e2a89ee1","modified":1517036866000},{"_id":"themes/apollo/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1517036866000},{"_id":"themes/apollo/.git/logs/refs/remotes/origin/HEAD","hash":"cc7af1c7286831ba5897a284cc8ea633e2a89ee1","modified":1517036866000},{"_id":"themes/apollo/.git/objects/pack/pack-d4037f7bd0574dc47f0bcf9f58fc3fc03ef440d5.pack","hash":"2ed346577d21354593bd73cd52109e9ac180cf48","modified":1517036866000},{"_id":"public/atom.xml","hash":"d072da6139e5e8b0ba838657e1355ebde3313e6f","modified":1518860197144},{"_id":"public/sitemap.xml","hash":"4be09d6faf3177e684bc73e131ffa2c20b24bb1b","modified":1518860197145},{"_id":"public/2018/02/04/vim-operator-pending-md/index.html","hash":"68db405159b069c06de74a45b44f92626619663a","modified":1518859555943},{"_id":"public/2018/02/01/mysql_notes_1/index.html","hash":"38a86d9fe5deb32a67b6259386aa458ce338cdcb","modified":1518859555943},{"_id":"public/archives/index.html","hash":"30ad0ba8507fed0ebcf1be3fbb9c4572b7c89206","modified":1518860197148},{"_id":"public/index.html","hash":"06eb6111879901362920eb297652182591e18cd1","modified":1518860197148},{"_id":"public/tags/mysql/index.html","hash":"9f9da31daba9f1d8295fb965ebaf7fe156d4a889","modified":1518859555943},{"_id":"public/tags/vim/index.html","hash":"ccd0247a71756c5856d977e6df506ad4ad88993f","modified":1518859555944},{"_id":"public/2018/02/14/concurrency-notes/index.html","hash":"07ede9284a1b32dab6459b41639723fca1a6bae6","modified":1518860197148},{"_id":"public/favicon.png","hash":"a9cdcb22d1e74d5480323e19d1983de5a6873b8c","modified":1518859555946},{"_id":"public/scss/apollo.scss","hash":"e0092f469264b55b25e0d441274f1c812147e7d1","modified":1518859555946},{"_id":"public/font/sourcesanspro.woff2","hash":"da65f527a8da65d5eb6721626d28cfdb46ab104a","modified":1518859555946},{"_id":"public/font/sourcesanspro.woff","hash":"a6722c9b6439b7a020a9be3d3178970757a9265c","modified":1518859555946},{"_id":"public/css/apollo.css","hash":"e07a11a5da5fc097f023e06a85575356066afd09","modified":1518859555948},{"_id":"public/images/mysql_layer.png","hash":"a430c15c6fea755c31aeeb4092867e594efbd472","modified":1518859555948},{"_id":"public/tags/java/index.html","hash":"8300d9f2007e669544a095fc0abdb497e3e0b865","modified":1518860197148}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"并发编程笔记 (一)","date":"2018-02-14T14:45:33.000Z","_content":"\n并发容器\n---------\n\n增强了同步同步容器类, \n\n### ConcurrentHashMap\n\n* 在迭代时不需要加锁\n* 具有若一致性, 而不是即时失败\n\n### CopyOnWriteArrayList\n\n* 安全读取, 写入时复制\n  - 保留一个指向底层基础数组的索引, 它不会被修改, 因此其他线程可以安全迭代\n\n处理InterruptedException\n------------------------\n\n抛出该异常表示该方法可能长时间阻塞\n\n* 向调用层抛出\n* 调用 `Thread.currentThread().interrput()` 中断当前线程\n\n闭锁\n-----\n\n用于控制多个线程在同一时间点做某件事情, `awati()` 方法调用后直到该 `countDownLatch` 值\n为1, 否则一直阻塞\n\n信号量\n------\n\n信号量管理一组 __许可__, 执行操作时首先通过 `acquire()` 获取许可, 执行完后再通过 `release()`\n返回许可, 当没有许可时 `acquire()` 会阻塞或抛出异常\n\n__例子: 通过信号量实现有界容器__\n\n```java\n\npublic class BoundedSet<T> {\n\n  private final Set<T> innerSet;\n  private final Semaphore sem;\n\n  public BoundedSet(int bound) {\n    // 封装为同步容器, 多个线程会添加或删除\n    this.innerSet = Collections.synchronizedSet(new HashSet<>());\n    this.sem = new Semaphore(bound);\n  }\n\n  public boolean add(T t) throws InterruptedException {\n    // 添加时若容器已满则阻塞\n    sem.acquire();\n    return innerSet.add(t);\n  }\n\n  public boolean remove(T t) {\n    boolean removed = innerSet.remove(t);\n    if (removed) {\n      // 删除时若删除成功则返回许可\n      sem.release();\n    }\n    return removed;\n  }\n\n  public static void main(String[] args) throws InterruptedException {\n    // 测试, 先充满容器, 再添加元素时应该阻塞, 两秒后删除某个元素后\n    // 应该可以继续正常添加\n    int bound = 10;\n    BoundedSet<Integer> boundedSet = new BoundedSet<>(bound);\n\n    for (int i = 0; i < 10; i++) {\n      boundedSet.add(i);\n    }\n\n    new Thread(() -> {\n      try {\n        TimeUnit.SECONDS.sleep(2);\n      } catch (InterruptedException e) {\n        e.printStackTrace();\n      }\n      boundedSet.remove(8);\n    }).start();\n\n    System.out.println(\"start adding 11\");\n    boundedSet.add(10);\n    System.out.println(\"this should appear after 2 seconds\");\n\n  }\n}\n\n```\n\n栅栏barrier\n-----------\n\n可以确保在并行计算中, 每个线程都执行完第K步操作后才进入第K+1步\n\n### 与闭锁的区别\n\n所有线程必须同时到 __栅栏的位置__ 才可以继续运行\n这个 __位置__ 可以由线程自己调用\n\nMemorzer缓存实例\n------------\n\n```java\n\npublic class Memoizer<A, V> implements Computable<A, V> {\n\n  private final ConcurrentMap<A, Future<V>> cache\n      = new ConcurrentHashMap<>();\n\n  private final Computable<A, V> c;\n\n  public Memoizer(Computable<A, V> c) {\n    this.c = c;\n  }\n\n  @Override\n  public V compute(A a) throws InterruptedException {\n    while (true) {\n      Future<V> f = cache.get(a);\n      // 缓存中没有值\n      if (f == null) {\n        FutureTask<V> ft = new FutureTask<>(() -> c.compute(a));\n        // 这时其他线程可能已经放入了future\n        f = cache.putIfAbsent(a, ft);\n        // 如果已经有future了则不替换 (putIfAbsent是原子操作)\n        if (f == null) {\n          f = ft;\n          // 否则运行future\n          // 可保证future只运行一次\n          ft.run();\n        }\n      }\n      try {\n        // 只要有线程在计算则会阻塞 (因为不会被替换)\n        return f.get();\n      } catch (ExecutionException e) {\n        e.printStackTrace();\n      }\n    }\n  }\n\n}\n\n```\n\nCompletionService\n-----------------\n\n将 _Executor_ 与 _BlockingQueue_ 结合到一起, 可以通过 `take()` 异步获取已经完成的任务\n\n线程中断\n---------\n\n调用中断不意味着立即停止, 而只是发起了停止请求， 在适当的时候执行中断, 并做好清理工作\n\n可以通过 `Thread.currentThread.isInterrupted` 方法判断当前线程是否已经收到了中断请求\n\n### 响应中断\n\n有两种策略可以用于处理 `InterruptedException`\n\n1. 抛出中断异常\n2. __恢复__ 中断状态, 使得上层代码可以处理中断\n\n关于第二中方式, 刚看书的时候并不明白什么叫 _恢复中断_,\n查了一下找到了这篇[解释](https://stackoverflow.com/questions/4906799/why-invoke-thread-currentthread-interrupt-in-a-catch-interruptexception-block)\n\n在捕获 `InterruptedException` 后会清除当前的中断状态, 所以外部线程无法看到该线程是否中断,\n因此才需要调用`Thread.currentThread().interrupt()` 来重新设置线程的中断状态, 从而使外部线程可以处理\n\n**如下面这个例子**\n\n如果在异常捕获后没有设置当前线程的 `interrupt`,\n那么在一次中断后当前线程在调用 `sleep` 或者 `take`\n这样的阻塞方法时仍然会继续阻塞, 因为它们看不到当前线程的已阻塞标志\n\n而手动调用 `Thread.currentThread.isInterrupted` 后在下次循环时 `sleep` 或者\n`take` 方法可以看到该线程已经中断, 因此会直接再次抛出中断异常\n\n```java\n\npublic class QueueInterruptTest {\n\n  private static BlockingQueue<Integer> QUEUE\n      = new ArrayBlockingQueue<>(1);\n\n  public static void main(String[] args) throws InterruptedException {\n    // 该线程会在take或sleep处阻塞直到外部调用中断\n    Thread t = new Thread(() -> {\n      while (true) {\n        try {\n          TimeUnit.SECONDS.sleep(5);\n        } catch (InterruptedException e) {\n          System.out.println(\"ignore sleep interrupt\");\n          // 不显式调用该方法则下次循环到该处还会继续阻塞\n          // 因为sleep看不到该线程已被中断\n          // Thread.currentThread().interrupt();\n        }\n        System.out.println(\"still looping...\");\n        try {\n          QUEUE.take();\n        } catch (InterruptedException e) {\n          System.out.println(\"take interrupt\");\n          // Thread.currentThread().interrupt();\n        }\n      }\n    });\n    t.start();\n\n    // 启动一个线程10秒后中断BlockingQueue的线程\n    new Thread(() -> {\n      try {\n        TimeUnit.SECONDS.sleep(10);\n      } catch (InterruptedException e) {\n        e.printStackTrace();\n      }\n      System.out.println(\"interrupt t, status: \" + t.isInterrupted());\n      t.interrupt();\n    }).start();\n  }\n\n}\n\n```\n\n### 处理不可中断的阻塞\n\n以下几种阻塞操作不会抛出 `interruptexception`, 因此需要手动调用相关的方法关闭阻塞操作,\n可以复写线程的 `interrput` 方法在响应中断时进行相应的处理\n\n* 同步/异步 IO 手动调用关闭IO\n* 获取某个锁而阻塞 通过 `lockInterruptibly` 中断锁等待\n","source":"_posts/concurrency-notes.md","raw":"---\ntitle: 并发编程笔记 (一)\ndate: 2018-02-14 22:45:33\ntags: java\n---\n\n并发容器\n---------\n\n增强了同步同步容器类, \n\n### ConcurrentHashMap\n\n* 在迭代时不需要加锁\n* 具有若一致性, 而不是即时失败\n\n### CopyOnWriteArrayList\n\n* 安全读取, 写入时复制\n  - 保留一个指向底层基础数组的索引, 它不会被修改, 因此其他线程可以安全迭代\n\n处理InterruptedException\n------------------------\n\n抛出该异常表示该方法可能长时间阻塞\n\n* 向调用层抛出\n* 调用 `Thread.currentThread().interrput()` 中断当前线程\n\n闭锁\n-----\n\n用于控制多个线程在同一时间点做某件事情, `awati()` 方法调用后直到该 `countDownLatch` 值\n为1, 否则一直阻塞\n\n信号量\n------\n\n信号量管理一组 __许可__, 执行操作时首先通过 `acquire()` 获取许可, 执行完后再通过 `release()`\n返回许可, 当没有许可时 `acquire()` 会阻塞或抛出异常\n\n__例子: 通过信号量实现有界容器__\n\n```java\n\npublic class BoundedSet<T> {\n\n  private final Set<T> innerSet;\n  private final Semaphore sem;\n\n  public BoundedSet(int bound) {\n    // 封装为同步容器, 多个线程会添加或删除\n    this.innerSet = Collections.synchronizedSet(new HashSet<>());\n    this.sem = new Semaphore(bound);\n  }\n\n  public boolean add(T t) throws InterruptedException {\n    // 添加时若容器已满则阻塞\n    sem.acquire();\n    return innerSet.add(t);\n  }\n\n  public boolean remove(T t) {\n    boolean removed = innerSet.remove(t);\n    if (removed) {\n      // 删除时若删除成功则返回许可\n      sem.release();\n    }\n    return removed;\n  }\n\n  public static void main(String[] args) throws InterruptedException {\n    // 测试, 先充满容器, 再添加元素时应该阻塞, 两秒后删除某个元素后\n    // 应该可以继续正常添加\n    int bound = 10;\n    BoundedSet<Integer> boundedSet = new BoundedSet<>(bound);\n\n    for (int i = 0; i < 10; i++) {\n      boundedSet.add(i);\n    }\n\n    new Thread(() -> {\n      try {\n        TimeUnit.SECONDS.sleep(2);\n      } catch (InterruptedException e) {\n        e.printStackTrace();\n      }\n      boundedSet.remove(8);\n    }).start();\n\n    System.out.println(\"start adding 11\");\n    boundedSet.add(10);\n    System.out.println(\"this should appear after 2 seconds\");\n\n  }\n}\n\n```\n\n栅栏barrier\n-----------\n\n可以确保在并行计算中, 每个线程都执行完第K步操作后才进入第K+1步\n\n### 与闭锁的区别\n\n所有线程必须同时到 __栅栏的位置__ 才可以继续运行\n这个 __位置__ 可以由线程自己调用\n\nMemorzer缓存实例\n------------\n\n```java\n\npublic class Memoizer<A, V> implements Computable<A, V> {\n\n  private final ConcurrentMap<A, Future<V>> cache\n      = new ConcurrentHashMap<>();\n\n  private final Computable<A, V> c;\n\n  public Memoizer(Computable<A, V> c) {\n    this.c = c;\n  }\n\n  @Override\n  public V compute(A a) throws InterruptedException {\n    while (true) {\n      Future<V> f = cache.get(a);\n      // 缓存中没有值\n      if (f == null) {\n        FutureTask<V> ft = new FutureTask<>(() -> c.compute(a));\n        // 这时其他线程可能已经放入了future\n        f = cache.putIfAbsent(a, ft);\n        // 如果已经有future了则不替换 (putIfAbsent是原子操作)\n        if (f == null) {\n          f = ft;\n          // 否则运行future\n          // 可保证future只运行一次\n          ft.run();\n        }\n      }\n      try {\n        // 只要有线程在计算则会阻塞 (因为不会被替换)\n        return f.get();\n      } catch (ExecutionException e) {\n        e.printStackTrace();\n      }\n    }\n  }\n\n}\n\n```\n\nCompletionService\n-----------------\n\n将 _Executor_ 与 _BlockingQueue_ 结合到一起, 可以通过 `take()` 异步获取已经完成的任务\n\n线程中断\n---------\n\n调用中断不意味着立即停止, 而只是发起了停止请求， 在适当的时候执行中断, 并做好清理工作\n\n可以通过 `Thread.currentThread.isInterrupted` 方法判断当前线程是否已经收到了中断请求\n\n### 响应中断\n\n有两种策略可以用于处理 `InterruptedException`\n\n1. 抛出中断异常\n2. __恢复__ 中断状态, 使得上层代码可以处理中断\n\n关于第二中方式, 刚看书的时候并不明白什么叫 _恢复中断_,\n查了一下找到了这篇[解释](https://stackoverflow.com/questions/4906799/why-invoke-thread-currentthread-interrupt-in-a-catch-interruptexception-block)\n\n在捕获 `InterruptedException` 后会清除当前的中断状态, 所以外部线程无法看到该线程是否中断,\n因此才需要调用`Thread.currentThread().interrupt()` 来重新设置线程的中断状态, 从而使外部线程可以处理\n\n**如下面这个例子**\n\n如果在异常捕获后没有设置当前线程的 `interrupt`,\n那么在一次中断后当前线程在调用 `sleep` 或者 `take`\n这样的阻塞方法时仍然会继续阻塞, 因为它们看不到当前线程的已阻塞标志\n\n而手动调用 `Thread.currentThread.isInterrupted` 后在下次循环时 `sleep` 或者\n`take` 方法可以看到该线程已经中断, 因此会直接再次抛出中断异常\n\n```java\n\npublic class QueueInterruptTest {\n\n  private static BlockingQueue<Integer> QUEUE\n      = new ArrayBlockingQueue<>(1);\n\n  public static void main(String[] args) throws InterruptedException {\n    // 该线程会在take或sleep处阻塞直到外部调用中断\n    Thread t = new Thread(() -> {\n      while (true) {\n        try {\n          TimeUnit.SECONDS.sleep(5);\n        } catch (InterruptedException e) {\n          System.out.println(\"ignore sleep interrupt\");\n          // 不显式调用该方法则下次循环到该处还会继续阻塞\n          // 因为sleep看不到该线程已被中断\n          // Thread.currentThread().interrupt();\n        }\n        System.out.println(\"still looping...\");\n        try {\n          QUEUE.take();\n        } catch (InterruptedException e) {\n          System.out.println(\"take interrupt\");\n          // Thread.currentThread().interrupt();\n        }\n      }\n    });\n    t.start();\n\n    // 启动一个线程10秒后中断BlockingQueue的线程\n    new Thread(() -> {\n      try {\n        TimeUnit.SECONDS.sleep(10);\n      } catch (InterruptedException e) {\n        e.printStackTrace();\n      }\n      System.out.println(\"interrupt t, status: \" + t.isInterrupted());\n      t.interrupt();\n    }).start();\n  }\n\n}\n\n```\n\n### 处理不可中断的阻塞\n\n以下几种阻塞操作不会抛出 `interruptexception`, 因此需要手动调用相关的方法关闭阻塞操作,\n可以复写线程的 `interrput` 方法在响应中断时进行相应的处理\n\n* 同步/异步 IO 手动调用关闭IO\n* 获取某个锁而阻塞 通过 `lockInterruptibly` 中断锁等待\n","slug":"concurrency-notes","published":1,"updated":"2018-02-17T09:35:24.967Z","_id":"cjdr5rhja00006h2jv7imut1i","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"并发容器\"><a href=\"#并发容器\" class=\"headerlink\" title=\"并发容器\"></a>并发容器</h2><p>增强了同步同步容器类, </p>\n<h3 id=\"ConcurrentHashMap\"><a href=\"#ConcurrentHashMap\" class=\"headerlink\" title=\"ConcurrentHashMap\"></a>ConcurrentHashMap</h3><ul>\n<li>在迭代时不需要加锁</li>\n<li>具有若一致性, 而不是即时失败</li>\n</ul>\n<h3 id=\"CopyOnWriteArrayList\"><a href=\"#CopyOnWriteArrayList\" class=\"headerlink\" title=\"CopyOnWriteArrayList\"></a>CopyOnWriteArrayList</h3><ul>\n<li>安全读取, 写入时复制<ul>\n<li>保留一个指向底层基础数组的索引, 它不会被修改, 因此其他线程可以安全迭代</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"处理InterruptedException\"><a href=\"#处理InterruptedException\" class=\"headerlink\" title=\"处理InterruptedException\"></a>处理InterruptedException</h2><p>抛出该异常表示该方法可能长时间阻塞</p>\n<ul>\n<li>向调用层抛出</li>\n<li>调用 <code>Thread.currentThread().interrput()</code> 中断当前线程</li>\n</ul>\n<h2 id=\"闭锁\"><a href=\"#闭锁\" class=\"headerlink\" title=\"闭锁\"></a>闭锁</h2><p>用于控制多个线程在同一时间点做某件事情, <code>awati()</code> 方法调用后直到该 <code>countDownLatch</code> 值<br>为1, 否则一直阻塞</p>\n<h2 id=\"信号量\"><a href=\"#信号量\" class=\"headerlink\" title=\"信号量\"></a>信号量</h2><p>信号量管理一组 <strong>许可</strong>, 执行操作时首先通过 <code>acquire()</code> 获取许可, 执行完后再通过 <code>release()</code><br>返回许可, 当没有许可时 <code>acquire()</code> 会阻塞或抛出异常</p>\n<p><strong>例子: 通过信号量实现有界容器</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BoundedSet</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Set&lt;T&gt; innerSet;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Semaphore sem;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">BoundedSet</span><span class=\"params\">(<span class=\"keyword\">int</span> bound)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 封装为同步容器, 多个线程会添加或删除</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.innerSet = Collections.synchronizedSet(<span class=\"keyword\">new</span> HashSet&lt;&gt;());</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.sem = <span class=\"keyword\">new</span> Semaphore(bound);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">add</span><span class=\"params\">(T t)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 添加时若容器已满则阻塞</span></span><br><span class=\"line\">    sem.acquire();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> innerSet.add(t);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">remove</span><span class=\"params\">(T t)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> removed = innerSet.remove(t);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (removed) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 删除时若删除成功则返回许可</span></span><br><span class=\"line\">      sem.release();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> removed;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 测试, 先充满容器, 再添加元素时应该阻塞, 两秒后删除某个元素后</span></span><br><span class=\"line\">    <span class=\"comment\">// 应该可以继续正常添加</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> bound = <span class=\"number\">10</span>;</span><br><span class=\"line\">    BoundedSet&lt;Integer&gt; boundedSet = <span class=\"keyword\">new</span> BoundedSet&lt;&gt;(bound);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">      boundedSet.add(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        TimeUnit.SECONDS.sleep(<span class=\"number\">2</span>);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      boundedSet.remove(<span class=\"number\">8</span>);</span><br><span class=\"line\">    &#125;).start();</span><br><span class=\"line\"></span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"start adding 11\"</span>);</span><br><span class=\"line\">    boundedSet.add(<span class=\"number\">10</span>);</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"this should appear after 2 seconds\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"栅栏barrier\"><a href=\"#栅栏barrier\" class=\"headerlink\" title=\"栅栏barrier\"></a>栅栏barrier</h2><p>可以确保在并行计算中, 每个线程都执行完第K步操作后才进入第K+1步</p>\n<h3 id=\"与闭锁的区别\"><a href=\"#与闭锁的区别\" class=\"headerlink\" title=\"与闭锁的区别\"></a>与闭锁的区别</h3><p>所有线程必须同时到 <strong>栅栏的位置</strong> 才可以继续运行<br>这个 <strong>位置</strong> 可以由线程自己调用</p>\n<h2 id=\"Memorzer缓存实例\"><a href=\"#Memorzer缓存实例\" class=\"headerlink\" title=\"Memorzer缓存实例\"></a>Memorzer缓存实例</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Memoizer</span>&lt;<span class=\"title\">A</span>, <span class=\"title\">V</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Computable</span>&lt;<span class=\"title\">A</span>, <span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ConcurrentMap&lt;A, Future&lt;V&gt;&gt; cache</span><br><span class=\"line\">      = <span class=\"keyword\">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Computable&lt;A, V&gt; c;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Memoizer</span><span class=\"params\">(Computable&lt;A, V&gt; c)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.c = c;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">compute</span><span class=\"params\">(A a)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">      Future&lt;V&gt; f = cache.get(a);</span><br><span class=\"line\">      <span class=\"comment\">// 缓存中没有值</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (f == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        FutureTask&lt;V&gt; ft = <span class=\"keyword\">new</span> FutureTask&lt;&gt;(() -&gt; c.compute(a));</span><br><span class=\"line\">        <span class=\"comment\">// 这时其他线程可能已经放入了future</span></span><br><span class=\"line\">        f = cache.putIfAbsent(a, ft);</span><br><span class=\"line\">        <span class=\"comment\">// 如果已经有future了则不替换 (putIfAbsent是原子操作)</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (f == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">          f = ft;</span><br><span class=\"line\">          <span class=\"comment\">// 否则运行future</span></span><br><span class=\"line\">          <span class=\"comment\">// 可保证future只运行一次</span></span><br><span class=\"line\">          ft.run();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 只要有线程在计算则会阻塞 (因为不会被替换)</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> f.get();</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (ExecutionException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"CompletionService\"><a href=\"#CompletionService\" class=\"headerlink\" title=\"CompletionService\"></a>CompletionService</h2><p>将 <em>Executor</em> 与 <em>BlockingQueue</em> 结合到一起, 可以通过 <code>take()</code> 异步获取已经完成的任务</p>\n<h2 id=\"线程中断\"><a href=\"#线程中断\" class=\"headerlink\" title=\"线程中断\"></a>线程中断</h2><p>调用中断不意味着立即停止, 而只是发起了停止请求， 在适当的时候执行中断, 并做好清理工作</p>\n<p>可以通过 <code>Thread.currentThread.isInterrupted</code> 方法判断当前线程是否已经收到了中断请求</p>\n<h3 id=\"响应中断\"><a href=\"#响应中断\" class=\"headerlink\" title=\"响应中断\"></a>响应中断</h3><p>有两种策略可以用于处理 <code>InterruptedException</code></p>\n<ol>\n<li>抛出中断异常</li>\n<li><strong>恢复</strong> 中断状态, 使得上层代码可以处理中断</li>\n</ol>\n<p>关于第二中方式, 刚看书的时候并不明白什么叫 <em>恢复中断</em>,<br>查了一下找到了这篇<a href=\"https://stackoverflow.com/questions/4906799/why-invoke-thread-currentthread-interrupt-in-a-catch-interruptexception-block\" target=\"_blank\" rel=\"noopener\">解释</a></p>\n<p>在捕获 <code>InterruptedException</code> 后会清除当前的中断状态, 所以外部线程无法看到该线程是否中断,<br>因此才需要调用<code>Thread.currentThread().interrupt()</code> 来重新设置线程的中断状态, 从而使外部线程可以处理</p>\n<p><strong>如下面这个例子</strong></p>\n<p>如果在异常捕获后没有设置当前线程的 <code>interrupt</code>,<br>那么在一次中断后当前线程在调用 <code>sleep</code> 或者 <code>take</code><br>这样的阻塞方法时仍然会继续阻塞, 因为它们看不到当前线程的已阻塞标志</p>\n<p>而手动调用 <code>Thread.currentThread.isInterrupted</code> 后在下次循环时 <code>sleep</code> 或者<br><code>take</code> 方法可以看到该线程已经中断, 因此会直接再次抛出中断异常</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">QueueInterruptTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> BlockingQueue&lt;Integer&gt; QUEUE</span><br><span class=\"line\">      = <span class=\"keyword\">new</span> ArrayBlockingQueue&lt;&gt;(<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 该线程会在take或sleep处阻塞直到外部调用中断</span></span><br><span class=\"line\">    Thread t = <span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">      <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          TimeUnit.SECONDS.sleep(<span class=\"number\">5</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">          System.out.println(<span class=\"string\">\"ignore sleep interrupt\"</span>);</span><br><span class=\"line\">          <span class=\"comment\">// 不显式调用该方法则下次循环到该处还会继续阻塞</span></span><br><span class=\"line\">          <span class=\"comment\">// 因为sleep看不到该线程已被中断</span></span><br><span class=\"line\">          <span class=\"comment\">// Thread.currentThread().interrupt();</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"still looping...\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          QUEUE.take();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">          System.out.println(<span class=\"string\">\"take interrupt\"</span>);</span><br><span class=\"line\">          <span class=\"comment\">// Thread.currentThread().interrupt();</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    t.start();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 启动一个线程10秒后中断BlockingQueue的线程</span></span><br><span class=\"line\">    <span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        TimeUnit.SECONDS.sleep(<span class=\"number\">10</span>);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      System.out.println(<span class=\"string\">\"interrupt t, status: \"</span> + t.isInterrupted());</span><br><span class=\"line\">      t.interrupt();</span><br><span class=\"line\">    &#125;).start();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"处理不可中断的阻塞\"><a href=\"#处理不可中断的阻塞\" class=\"headerlink\" title=\"处理不可中断的阻塞\"></a>处理不可中断的阻塞</h3><p>以下几种阻塞操作不会抛出 <code>interruptexception</code>, 因此需要手动调用相关的方法关闭阻塞操作,<br>可以复写线程的 <code>interrput</code> 方法在响应中断时进行相应的处理</p>\n<ul>\n<li>同步/异步 IO 手动调用关闭IO</li>\n<li>获取某个锁而阻塞 通过 <code>lockInterruptibly</code> 中断锁等待</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"并发容器\"><a href=\"#并发容器\" class=\"headerlink\" title=\"并发容器\"></a>并发容器</h2><p>增强了同步同步容器类, </p>\n<h3 id=\"ConcurrentHashMap\"><a href=\"#ConcurrentHashMap\" class=\"headerlink\" title=\"ConcurrentHashMap\"></a>ConcurrentHashMap</h3><ul>\n<li>在迭代时不需要加锁</li>\n<li>具有若一致性, 而不是即时失败</li>\n</ul>\n<h3 id=\"CopyOnWriteArrayList\"><a href=\"#CopyOnWriteArrayList\" class=\"headerlink\" title=\"CopyOnWriteArrayList\"></a>CopyOnWriteArrayList</h3><ul>\n<li>安全读取, 写入时复制<ul>\n<li>保留一个指向底层基础数组的索引, 它不会被修改, 因此其他线程可以安全迭代</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"处理InterruptedException\"><a href=\"#处理InterruptedException\" class=\"headerlink\" title=\"处理InterruptedException\"></a>处理InterruptedException</h2><p>抛出该异常表示该方法可能长时间阻塞</p>\n<ul>\n<li>向调用层抛出</li>\n<li>调用 <code>Thread.currentThread().interrput()</code> 中断当前线程</li>\n</ul>\n<h2 id=\"闭锁\"><a href=\"#闭锁\" class=\"headerlink\" title=\"闭锁\"></a>闭锁</h2><p>用于控制多个线程在同一时间点做某件事情, <code>awati()</code> 方法调用后直到该 <code>countDownLatch</code> 值<br>为1, 否则一直阻塞</p>\n<h2 id=\"信号量\"><a href=\"#信号量\" class=\"headerlink\" title=\"信号量\"></a>信号量</h2><p>信号量管理一组 <strong>许可</strong>, 执行操作时首先通过 <code>acquire()</code> 获取许可, 执行完后再通过 <code>release()</code><br>返回许可, 当没有许可时 <code>acquire()</code> 会阻塞或抛出异常</p>\n<p><strong>例子: 通过信号量实现有界容器</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BoundedSet</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Set&lt;T&gt; innerSet;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Semaphore sem;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">BoundedSet</span><span class=\"params\">(<span class=\"keyword\">int</span> bound)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 封装为同步容器, 多个线程会添加或删除</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.innerSet = Collections.synchronizedSet(<span class=\"keyword\">new</span> HashSet&lt;&gt;());</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.sem = <span class=\"keyword\">new</span> Semaphore(bound);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">add</span><span class=\"params\">(T t)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 添加时若容器已满则阻塞</span></span><br><span class=\"line\">    sem.acquire();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> innerSet.add(t);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">remove</span><span class=\"params\">(T t)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> removed = innerSet.remove(t);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (removed) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 删除时若删除成功则返回许可</span></span><br><span class=\"line\">      sem.release();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> removed;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 测试, 先充满容器, 再添加元素时应该阻塞, 两秒后删除某个元素后</span></span><br><span class=\"line\">    <span class=\"comment\">// 应该可以继续正常添加</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> bound = <span class=\"number\">10</span>;</span><br><span class=\"line\">    BoundedSet&lt;Integer&gt; boundedSet = <span class=\"keyword\">new</span> BoundedSet&lt;&gt;(bound);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">      boundedSet.add(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        TimeUnit.SECONDS.sleep(<span class=\"number\">2</span>);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      boundedSet.remove(<span class=\"number\">8</span>);</span><br><span class=\"line\">    &#125;).start();</span><br><span class=\"line\"></span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"start adding 11\"</span>);</span><br><span class=\"line\">    boundedSet.add(<span class=\"number\">10</span>);</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"this should appear after 2 seconds\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"栅栏barrier\"><a href=\"#栅栏barrier\" class=\"headerlink\" title=\"栅栏barrier\"></a>栅栏barrier</h2><p>可以确保在并行计算中, 每个线程都执行完第K步操作后才进入第K+1步</p>\n<h3 id=\"与闭锁的区别\"><a href=\"#与闭锁的区别\" class=\"headerlink\" title=\"与闭锁的区别\"></a>与闭锁的区别</h3><p>所有线程必须同时到 <strong>栅栏的位置</strong> 才可以继续运行<br>这个 <strong>位置</strong> 可以由线程自己调用</p>\n<h2 id=\"Memorzer缓存实例\"><a href=\"#Memorzer缓存实例\" class=\"headerlink\" title=\"Memorzer缓存实例\"></a>Memorzer缓存实例</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Memoizer</span>&lt;<span class=\"title\">A</span>, <span class=\"title\">V</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Computable</span>&lt;<span class=\"title\">A</span>, <span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ConcurrentMap&lt;A, Future&lt;V&gt;&gt; cache</span><br><span class=\"line\">      = <span class=\"keyword\">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Computable&lt;A, V&gt; c;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Memoizer</span><span class=\"params\">(Computable&lt;A, V&gt; c)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.c = c;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">compute</span><span class=\"params\">(A a)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">      Future&lt;V&gt; f = cache.get(a);</span><br><span class=\"line\">      <span class=\"comment\">// 缓存中没有值</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (f == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        FutureTask&lt;V&gt; ft = <span class=\"keyword\">new</span> FutureTask&lt;&gt;(() -&gt; c.compute(a));</span><br><span class=\"line\">        <span class=\"comment\">// 这时其他线程可能已经放入了future</span></span><br><span class=\"line\">        f = cache.putIfAbsent(a, ft);</span><br><span class=\"line\">        <span class=\"comment\">// 如果已经有future了则不替换 (putIfAbsent是原子操作)</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (f == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">          f = ft;</span><br><span class=\"line\">          <span class=\"comment\">// 否则运行future</span></span><br><span class=\"line\">          <span class=\"comment\">// 可保证future只运行一次</span></span><br><span class=\"line\">          ft.run();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 只要有线程在计算则会阻塞 (因为不会被替换)</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> f.get();</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (ExecutionException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"CompletionService\"><a href=\"#CompletionService\" class=\"headerlink\" title=\"CompletionService\"></a>CompletionService</h2><p>将 <em>Executor</em> 与 <em>BlockingQueue</em> 结合到一起, 可以通过 <code>take()</code> 异步获取已经完成的任务</p>\n<h2 id=\"线程中断\"><a href=\"#线程中断\" class=\"headerlink\" title=\"线程中断\"></a>线程中断</h2><p>调用中断不意味着立即停止, 而只是发起了停止请求， 在适当的时候执行中断, 并做好清理工作</p>\n<p>可以通过 <code>Thread.currentThread.isInterrupted</code> 方法判断当前线程是否已经收到了中断请求</p>\n<h3 id=\"响应中断\"><a href=\"#响应中断\" class=\"headerlink\" title=\"响应中断\"></a>响应中断</h3><p>有两种策略可以用于处理 <code>InterruptedException</code></p>\n<ol>\n<li>抛出中断异常</li>\n<li><strong>恢复</strong> 中断状态, 使得上层代码可以处理中断</li>\n</ol>\n<p>关于第二中方式, 刚看书的时候并不明白什么叫 <em>恢复中断</em>,<br>查了一下找到了这篇<a href=\"https://stackoverflow.com/questions/4906799/why-invoke-thread-currentthread-interrupt-in-a-catch-interruptexception-block\" target=\"_blank\" rel=\"noopener\">解释</a></p>\n<p>在捕获 <code>InterruptedException</code> 后会清除当前的中断状态, 所以外部线程无法看到该线程是否中断,<br>因此才需要调用<code>Thread.currentThread().interrupt()</code> 来重新设置线程的中断状态, 从而使外部线程可以处理</p>\n<p><strong>如下面这个例子</strong></p>\n<p>如果在异常捕获后没有设置当前线程的 <code>interrupt</code>,<br>那么在一次中断后当前线程在调用 <code>sleep</code> 或者 <code>take</code><br>这样的阻塞方法时仍然会继续阻塞, 因为它们看不到当前线程的已阻塞标志</p>\n<p>而手动调用 <code>Thread.currentThread.isInterrupted</code> 后在下次循环时 <code>sleep</code> 或者<br><code>take</code> 方法可以看到该线程已经中断, 因此会直接再次抛出中断异常</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">QueueInterruptTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> BlockingQueue&lt;Integer&gt; QUEUE</span><br><span class=\"line\">      = <span class=\"keyword\">new</span> ArrayBlockingQueue&lt;&gt;(<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 该线程会在take或sleep处阻塞直到外部调用中断</span></span><br><span class=\"line\">    Thread t = <span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">      <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          TimeUnit.SECONDS.sleep(<span class=\"number\">5</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">          System.out.println(<span class=\"string\">\"ignore sleep interrupt\"</span>);</span><br><span class=\"line\">          <span class=\"comment\">// 不显式调用该方法则下次循环到该处还会继续阻塞</span></span><br><span class=\"line\">          <span class=\"comment\">// 因为sleep看不到该线程已被中断</span></span><br><span class=\"line\">          <span class=\"comment\">// Thread.currentThread().interrupt();</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"still looping...\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          QUEUE.take();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">          System.out.println(<span class=\"string\">\"take interrupt\"</span>);</span><br><span class=\"line\">          <span class=\"comment\">// Thread.currentThread().interrupt();</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    t.start();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 启动一个线程10秒后中断BlockingQueue的线程</span></span><br><span class=\"line\">    <span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        TimeUnit.SECONDS.sleep(<span class=\"number\">10</span>);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      System.out.println(<span class=\"string\">\"interrupt t, status: \"</span> + t.isInterrupted());</span><br><span class=\"line\">      t.interrupt();</span><br><span class=\"line\">    &#125;).start();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"处理不可中断的阻塞\"><a href=\"#处理不可中断的阻塞\" class=\"headerlink\" title=\"处理不可中断的阻塞\"></a>处理不可中断的阻塞</h3><p>以下几种阻塞操作不会抛出 <code>interruptexception</code>, 因此需要手动调用相关的方法关闭阻塞操作,<br>可以复写线程的 <code>interrput</code> 方法在响应中断时进行相应的处理</p>\n<ul>\n<li>同步/异步 IO 手动调用关闭IO</li>\n<li>获取某个锁而阻塞 通过 <code>lockInterruptibly</code> 中断锁等待</li>\n</ul>\n"},{"title":"mysql笔记 (一)","date":"2018-02-01T14:59:05.000Z","_content":"\n- [层级结构](#%E5%B1%82%E7%BA%A7%E7%BB%93%E6%9E%84)\n- [存储引擎](#%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E)\n    - [MyISAM](#myisam)\n        - [索引支持](#%E7%B4%A2%E5%BC%95%E6%94%AF%E6%8C%81)\n    - [InnoDB](#innodb)\n        - [主要特性](#%E4%B8%BB%E8%A6%81%E7%89%B9%E6%80%A7)\n- [权限级别](#%E6%9D%83%E9%99%90%E7%BA%A7%E5%88%AB)\n    - [Global Level](#global-level)\n    - [Database Level](#database-level)\n    - [Tabel Level](#tabel-level)\n    - [Column Level](#column-level)\n    - [Routine Level](#routine-level)\n    - [GRANT](#grant)\n\n# 层级结构\n\n__Sql Layer__ 负责查询相关, __Storage Engine Layer__ 底层数据存储相关\n\n将存储与计算分离\n\n![mysql_layer.png](/images/mysql_layer.png)\n\n# 存储引擎\n\n## MyISAM\n\n### 索引支持\n\n1. B-Tree\n    - 按照 _B-Tree_ 结构存储数据\n2. R-Tree\n    - 设计用于为存储空间和多维数据的字段做索引 (暂时不是很明白这段话的意思)\n3. Full-Text\n    - 全文检索, 提高 _LIKE_ 查询的效率\n\n## InnoDB\n\n### 主要特性\n\n1. 支持事务安全\n2. 数据多版本读取\n3. 锁定机制改进\n    - 改变了MyISAM的锁机制实现了行锁\n4. 实现外建\n\n# 权限级别\n\n## Global Level\n\n全局级别, __拥有最高优先级__\n\n`*.*` 表示全局作用域\n\n示例:\n\n```sql\nGRANT SELECT,UPDATE,DELETE,INSERT ON *.* TO 'def'@'localhost';\n```\n\n## Database Level\n\n`database.*` 表示数据库级别作用域\n\n示例:\n\n```sql\nGRANT ALTER ON test.* TO 'def'@'localhost';\n```\n\n也可以先选定数据库, 然后通过 `*` 来限定作用域为当前数据库, 如:\n\n```sql\nUSE test;\nGRANT DROP ON * TO 'def'@'localhost';\n```\n\n多个用户可以用逗号隔开:\n\n```sql\nGRANT CREATE ON perf.* TO 'abc'@'localhost','def'@'localhost';\n```\n\n## Tabel Level\n\n`database.table` 表级别作用域\n\n示例:\n\n其中 _%_ 表示通配符\n\n```sql\nGRANT INDEX ON test.t1 TO 'abc'@'%.jianzhaoyang.com';\n```\n\n## Column Level\n\n列级别, 语法与 _Table Level_ 相似, 只是需要在括号中指定列\n\n示例:\n\n```sql\nGRANT SELECT(id,value) ON test.t2 TO 'abc'@'%.jianzhaoyang.com';\n```\n\n## Routine Level\n\n主要针对 _procedure_ 和 _function_\n\n## GRANT\n\n特殊权限, 拥有该权限的用户可以将 __自身__ 拥有的权限赋予其他用户\n\n示例:\n\n```sql\nGRANT ALL ON test.t5 TO 'abc';\n```","source":"_posts/mysql_notes_1.md","raw":"---\ntitle: mysql笔记 (一)\ndate: 2018-02-01 22:59:05\ntags: mysql\n---\n\n- [层级结构](#%E5%B1%82%E7%BA%A7%E7%BB%93%E6%9E%84)\n- [存储引擎](#%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E)\n    - [MyISAM](#myisam)\n        - [索引支持](#%E7%B4%A2%E5%BC%95%E6%94%AF%E6%8C%81)\n    - [InnoDB](#innodb)\n        - [主要特性](#%E4%B8%BB%E8%A6%81%E7%89%B9%E6%80%A7)\n- [权限级别](#%E6%9D%83%E9%99%90%E7%BA%A7%E5%88%AB)\n    - [Global Level](#global-level)\n    - [Database Level](#database-level)\n    - [Tabel Level](#tabel-level)\n    - [Column Level](#column-level)\n    - [Routine Level](#routine-level)\n    - [GRANT](#grant)\n\n# 层级结构\n\n__Sql Layer__ 负责查询相关, __Storage Engine Layer__ 底层数据存储相关\n\n将存储与计算分离\n\n![mysql_layer.png](/images/mysql_layer.png)\n\n# 存储引擎\n\n## MyISAM\n\n### 索引支持\n\n1. B-Tree\n    - 按照 _B-Tree_ 结构存储数据\n2. R-Tree\n    - 设计用于为存储空间和多维数据的字段做索引 (暂时不是很明白这段话的意思)\n3. Full-Text\n    - 全文检索, 提高 _LIKE_ 查询的效率\n\n## InnoDB\n\n### 主要特性\n\n1. 支持事务安全\n2. 数据多版本读取\n3. 锁定机制改进\n    - 改变了MyISAM的锁机制实现了行锁\n4. 实现外建\n\n# 权限级别\n\n## Global Level\n\n全局级别, __拥有最高优先级__\n\n`*.*` 表示全局作用域\n\n示例:\n\n```sql\nGRANT SELECT,UPDATE,DELETE,INSERT ON *.* TO 'def'@'localhost';\n```\n\n## Database Level\n\n`database.*` 表示数据库级别作用域\n\n示例:\n\n```sql\nGRANT ALTER ON test.* TO 'def'@'localhost';\n```\n\n也可以先选定数据库, 然后通过 `*` 来限定作用域为当前数据库, 如:\n\n```sql\nUSE test;\nGRANT DROP ON * TO 'def'@'localhost';\n```\n\n多个用户可以用逗号隔开:\n\n```sql\nGRANT CREATE ON perf.* TO 'abc'@'localhost','def'@'localhost';\n```\n\n## Tabel Level\n\n`database.table` 表级别作用域\n\n示例:\n\n其中 _%_ 表示通配符\n\n```sql\nGRANT INDEX ON test.t1 TO 'abc'@'%.jianzhaoyang.com';\n```\n\n## Column Level\n\n列级别, 语法与 _Table Level_ 相似, 只是需要在括号中指定列\n\n示例:\n\n```sql\nGRANT SELECT(id,value) ON test.t2 TO 'abc'@'%.jianzhaoyang.com';\n```\n\n## Routine Level\n\n主要针对 _procedure_ 和 _function_\n\n## GRANT\n\n特殊权限, 拥有该权限的用户可以将 __自身__ 拥有的权限赋予其他用户\n\n示例:\n\n```sql\nGRANT ALL ON test.t5 TO 'abc';\n```","slug":"mysql_notes_1","published":1,"updated":"2018-02-01T16:46:23.669Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdr5rhpe00016h2jtcg5pysp","content":"<ul>\n<li><a href=\"#%E5%B1%82%E7%BA%A7%E7%BB%93%E6%9E%84\">层级结构</a></li>\n<li><a href=\"#%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E\">存储引擎</a><ul>\n<li><a href=\"#myisam\">MyISAM</a><ul>\n<li><a href=\"#%E7%B4%A2%E5%BC%95%E6%94%AF%E6%8C%81\">索引支持</a></li>\n</ul>\n</li>\n<li><a href=\"#innodb\">InnoDB</a><ul>\n<li><a href=\"#%E4%B8%BB%E8%A6%81%E7%89%B9%E6%80%A7\">主要特性</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#%E6%9D%83%E9%99%90%E7%BA%A7%E5%88%AB\">权限级别</a><ul>\n<li><a href=\"#global-level\">Global Level</a></li>\n<li><a href=\"#database-level\">Database Level</a></li>\n<li><a href=\"#tabel-level\">Tabel Level</a></li>\n<li><a href=\"#column-level\">Column Level</a></li>\n<li><a href=\"#routine-level\">Routine Level</a></li>\n<li><a href=\"#grant\">GRANT</a></li>\n</ul>\n</li>\n</ul>\n<h1 id=\"层级结构\"><a href=\"#层级结构\" class=\"headerlink\" title=\"层级结构\"></a>层级结构</h1><p><strong>Sql Layer</strong> 负责查询相关, <strong>Storage Engine Layer</strong> 底层数据存储相关</p>\n<p>将存储与计算分离</p>\n<p><img src=\"/images/mysql_layer.png\" alt=\"mysql_layer.png\"></p>\n<h1 id=\"存储引擎\"><a href=\"#存储引擎\" class=\"headerlink\" title=\"存储引擎\"></a>存储引擎</h1><h2 id=\"MyISAM\"><a href=\"#MyISAM\" class=\"headerlink\" title=\"MyISAM\"></a>MyISAM</h2><h3 id=\"索引支持\"><a href=\"#索引支持\" class=\"headerlink\" title=\"索引支持\"></a>索引支持</h3><ol>\n<li>B-Tree<ul>\n<li>按照 <em>B-Tree</em> 结构存储数据</li>\n</ul>\n</li>\n<li>R-Tree<ul>\n<li>设计用于为存储空间和多维数据的字段做索引 (暂时不是很明白这段话的意思)</li>\n</ul>\n</li>\n<li>Full-Text<ul>\n<li>全文检索, 提高 <em>LIKE</em> 查询的效率</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"InnoDB\"><a href=\"#InnoDB\" class=\"headerlink\" title=\"InnoDB\"></a>InnoDB</h2><h3 id=\"主要特性\"><a href=\"#主要特性\" class=\"headerlink\" title=\"主要特性\"></a>主要特性</h3><ol>\n<li>支持事务安全</li>\n<li>数据多版本读取</li>\n<li>锁定机制改进<ul>\n<li>改变了MyISAM的锁机制实现了行锁</li>\n</ul>\n</li>\n<li>实现外建</li>\n</ol>\n<h1 id=\"权限级别\"><a href=\"#权限级别\" class=\"headerlink\" title=\"权限级别\"></a>权限级别</h1><h2 id=\"Global-Level\"><a href=\"#Global-Level\" class=\"headerlink\" title=\"Global Level\"></a>Global Level</h2><p>全局级别, <strong>拥有最高优先级</strong></p>\n<p><code>*.*</code> 表示全局作用域</p>\n<p>示例:</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">GRANT</span> <span class=\"keyword\">SELECT</span>,<span class=\"keyword\">UPDATE</span>,<span class=\"keyword\">DELETE</span>,<span class=\"keyword\">INSERT</span> <span class=\"keyword\">ON</span> *.* <span class=\"keyword\">TO</span> <span class=\"string\">'def'</span>@<span class=\"string\">'localhost'</span>;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Database-Level\"><a href=\"#Database-Level\" class=\"headerlink\" title=\"Database Level\"></a>Database Level</h2><p><code>database.*</code> 表示数据库级别作用域</p>\n<p>示例:</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">GRANT</span> <span class=\"keyword\">ALTER</span> <span class=\"keyword\">ON</span> test.* <span class=\"keyword\">TO</span> <span class=\"string\">'def'</span>@<span class=\"string\">'localhost'</span>;</span><br></pre></td></tr></table></figure>\n<p>也可以先选定数据库, 然后通过 <code>*</code> 来限定作用域为当前数据库, 如:</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">USE</span> <span class=\"keyword\">test</span>;</span><br><span class=\"line\"><span class=\"keyword\">GRANT</span> <span class=\"keyword\">DROP</span> <span class=\"keyword\">ON</span> * <span class=\"keyword\">TO</span> <span class=\"string\">'def'</span>@<span class=\"string\">'localhost'</span>;</span><br></pre></td></tr></table></figure>\n<p>多个用户可以用逗号隔开:</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">GRANT</span> <span class=\"keyword\">CREATE</span> <span class=\"keyword\">ON</span> perf.* <span class=\"keyword\">TO</span> <span class=\"string\">'abc'</span>@<span class=\"string\">'localhost'</span>,<span class=\"string\">'def'</span>@<span class=\"string\">'localhost'</span>;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Tabel-Level\"><a href=\"#Tabel-Level\" class=\"headerlink\" title=\"Tabel Level\"></a>Tabel Level</h2><p><code>database.table</code> 表级别作用域</p>\n<p>示例:</p>\n<p>其中 <em>%</em> 表示通配符</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">GRANT</span> <span class=\"keyword\">INDEX</span> <span class=\"keyword\">ON</span> test.t1 <span class=\"keyword\">TO</span> <span class=\"string\">'abc'</span>@<span class=\"string\">'%.jianzhaoyang.com'</span>;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Column-Level\"><a href=\"#Column-Level\" class=\"headerlink\" title=\"Column Level\"></a>Column Level</h2><p>列级别, 语法与 <em>Table Level</em> 相似, 只是需要在括号中指定列</p>\n<p>示例:</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">GRANT</span> <span class=\"keyword\">SELECT</span>(<span class=\"keyword\">id</span>,<span class=\"keyword\">value</span>) <span class=\"keyword\">ON</span> test.t2 <span class=\"keyword\">TO</span> <span class=\"string\">'abc'</span>@<span class=\"string\">'%.jianzhaoyang.com'</span>;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Routine-Level\"><a href=\"#Routine-Level\" class=\"headerlink\" title=\"Routine Level\"></a>Routine Level</h2><p>主要针对 <em>procedure</em> 和 <em>function</em></p>\n<h2 id=\"GRANT\"><a href=\"#GRANT\" class=\"headerlink\" title=\"GRANT\"></a>GRANT</h2><p>特殊权限, 拥有该权限的用户可以将 <strong>自身</strong> 拥有的权限赋予其他用户</p>\n<p>示例:</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">GRANT</span> ALL <span class=\"keyword\">ON</span> test.t5 <span class=\"keyword\">TO</span> <span class=\"string\">'abc'</span>;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<ul>\n<li><a href=\"#%E5%B1%82%E7%BA%A7%E7%BB%93%E6%9E%84\">层级结构</a></li>\n<li><a href=\"#%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E\">存储引擎</a><ul>\n<li><a href=\"#myisam\">MyISAM</a><ul>\n<li><a href=\"#%E7%B4%A2%E5%BC%95%E6%94%AF%E6%8C%81\">索引支持</a></li>\n</ul>\n</li>\n<li><a href=\"#innodb\">InnoDB</a><ul>\n<li><a href=\"#%E4%B8%BB%E8%A6%81%E7%89%B9%E6%80%A7\">主要特性</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#%E6%9D%83%E9%99%90%E7%BA%A7%E5%88%AB\">权限级别</a><ul>\n<li><a href=\"#global-level\">Global Level</a></li>\n<li><a href=\"#database-level\">Database Level</a></li>\n<li><a href=\"#tabel-level\">Tabel Level</a></li>\n<li><a href=\"#column-level\">Column Level</a></li>\n<li><a href=\"#routine-level\">Routine Level</a></li>\n<li><a href=\"#grant\">GRANT</a></li>\n</ul>\n</li>\n</ul>\n<h1 id=\"层级结构\"><a href=\"#层级结构\" class=\"headerlink\" title=\"层级结构\"></a>层级结构</h1><p><strong>Sql Layer</strong> 负责查询相关, <strong>Storage Engine Layer</strong> 底层数据存储相关</p>\n<p>将存储与计算分离</p>\n<p><img src=\"/images/mysql_layer.png\" alt=\"mysql_layer.png\"></p>\n<h1 id=\"存储引擎\"><a href=\"#存储引擎\" class=\"headerlink\" title=\"存储引擎\"></a>存储引擎</h1><h2 id=\"MyISAM\"><a href=\"#MyISAM\" class=\"headerlink\" title=\"MyISAM\"></a>MyISAM</h2><h3 id=\"索引支持\"><a href=\"#索引支持\" class=\"headerlink\" title=\"索引支持\"></a>索引支持</h3><ol>\n<li>B-Tree<ul>\n<li>按照 <em>B-Tree</em> 结构存储数据</li>\n</ul>\n</li>\n<li>R-Tree<ul>\n<li>设计用于为存储空间和多维数据的字段做索引 (暂时不是很明白这段话的意思)</li>\n</ul>\n</li>\n<li>Full-Text<ul>\n<li>全文检索, 提高 <em>LIKE</em> 查询的效率</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"InnoDB\"><a href=\"#InnoDB\" class=\"headerlink\" title=\"InnoDB\"></a>InnoDB</h2><h3 id=\"主要特性\"><a href=\"#主要特性\" class=\"headerlink\" title=\"主要特性\"></a>主要特性</h3><ol>\n<li>支持事务安全</li>\n<li>数据多版本读取</li>\n<li>锁定机制改进<ul>\n<li>改变了MyISAM的锁机制实现了行锁</li>\n</ul>\n</li>\n<li>实现外建</li>\n</ol>\n<h1 id=\"权限级别\"><a href=\"#权限级别\" class=\"headerlink\" title=\"权限级别\"></a>权限级别</h1><h2 id=\"Global-Level\"><a href=\"#Global-Level\" class=\"headerlink\" title=\"Global Level\"></a>Global Level</h2><p>全局级别, <strong>拥有最高优先级</strong></p>\n<p><code>*.*</code> 表示全局作用域</p>\n<p>示例:</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">GRANT</span> <span class=\"keyword\">SELECT</span>,<span class=\"keyword\">UPDATE</span>,<span class=\"keyword\">DELETE</span>,<span class=\"keyword\">INSERT</span> <span class=\"keyword\">ON</span> *.* <span class=\"keyword\">TO</span> <span class=\"string\">'def'</span>@<span class=\"string\">'localhost'</span>;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Database-Level\"><a href=\"#Database-Level\" class=\"headerlink\" title=\"Database Level\"></a>Database Level</h2><p><code>database.*</code> 表示数据库级别作用域</p>\n<p>示例:</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">GRANT</span> <span class=\"keyword\">ALTER</span> <span class=\"keyword\">ON</span> test.* <span class=\"keyword\">TO</span> <span class=\"string\">'def'</span>@<span class=\"string\">'localhost'</span>;</span><br></pre></td></tr></table></figure>\n<p>也可以先选定数据库, 然后通过 <code>*</code> 来限定作用域为当前数据库, 如:</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">USE</span> <span class=\"keyword\">test</span>;</span><br><span class=\"line\"><span class=\"keyword\">GRANT</span> <span class=\"keyword\">DROP</span> <span class=\"keyword\">ON</span> * <span class=\"keyword\">TO</span> <span class=\"string\">'def'</span>@<span class=\"string\">'localhost'</span>;</span><br></pre></td></tr></table></figure>\n<p>多个用户可以用逗号隔开:</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">GRANT</span> <span class=\"keyword\">CREATE</span> <span class=\"keyword\">ON</span> perf.* <span class=\"keyword\">TO</span> <span class=\"string\">'abc'</span>@<span class=\"string\">'localhost'</span>,<span class=\"string\">'def'</span>@<span class=\"string\">'localhost'</span>;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Tabel-Level\"><a href=\"#Tabel-Level\" class=\"headerlink\" title=\"Tabel Level\"></a>Tabel Level</h2><p><code>database.table</code> 表级别作用域</p>\n<p>示例:</p>\n<p>其中 <em>%</em> 表示通配符</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">GRANT</span> <span class=\"keyword\">INDEX</span> <span class=\"keyword\">ON</span> test.t1 <span class=\"keyword\">TO</span> <span class=\"string\">'abc'</span>@<span class=\"string\">'%.jianzhaoyang.com'</span>;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Column-Level\"><a href=\"#Column-Level\" class=\"headerlink\" title=\"Column Level\"></a>Column Level</h2><p>列级别, 语法与 <em>Table Level</em> 相似, 只是需要在括号中指定列</p>\n<p>示例:</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">GRANT</span> <span class=\"keyword\">SELECT</span>(<span class=\"keyword\">id</span>,<span class=\"keyword\">value</span>) <span class=\"keyword\">ON</span> test.t2 <span class=\"keyword\">TO</span> <span class=\"string\">'abc'</span>@<span class=\"string\">'%.jianzhaoyang.com'</span>;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Routine-Level\"><a href=\"#Routine-Level\" class=\"headerlink\" title=\"Routine Level\"></a>Routine Level</h2><p>主要针对 <em>procedure</em> 和 <em>function</em></p>\n<h2 id=\"GRANT\"><a href=\"#GRANT\" class=\"headerlink\" title=\"GRANT\"></a>GRANT</h2><p>特殊权限, 拥有该权限的用户可以将 <strong>自身</strong> 拥有的权限赋予其他用户</p>\n<p>示例:</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">GRANT</span> ALL <span class=\"keyword\">ON</span> test.t5 <span class=\"keyword\">TO</span> <span class=\"string\">'abc'</span>;</span><br></pre></td></tr></table></figure>"},{"title":"VIM中的Operator-Pending","date":"2018-02-04T08:37:17.000Z","_content":"\n关于VIM中的Operator-Pending映射\n=============================\n\nVIM已经用了有一年了, 但是这一年来基本上只是用到了最基本的功能, 并没有提高很多自己的码字效率,\n插件倒是装了一堆却并没有理解为什么,\n使用着强大的工具却不了解其运作原理总归让人有点不安, 所以趁这两天准备把VIM的基本运作方式搞搞清楚, 顺便给自己的 _.vimrc_ 瘦个身。\n\n首先, 看的是在线版本的 [Learn Vim The Hard Way][bookurl]\n\n前几章关于 _基本设置_ , _文件类型相关设置_ , _按键映射_ 方面的章节都还好, 到 [operator-padding][operator-padding]\n这一章就有点看不懂了, 主要是因为 _text-objects_ 有些不明白, 因此又看了另一篇 [博客][text-objects],\n搞懂了 _text-objects_ 之后再来看就简单多了。\n\nText-Objects\n-------------\n\nVIM中的 _text-objects_ 是更高效得操作单词、句子、段落的一个作用域对象, 称为 __文本对象__\n\n首先需要了解VIM的命令结构\n\nVIM中的命令结构如下\n\n```viml\n<number><command><text object or motion>\n```\n\n* __number__ 是指作用的文本对象数量, 它是可选的, 并且可以在之前或者之后出现\n\n* __commond__ 对文本对象的操作, 如删除、复制等, 它也是可选的, 但如果不指定则该命令就\n失去了编辑能力\n\n* __text objects or motion__ 指文本对象的作用域, 如一个单词(w), 一句话(s), 或一个段落(p)\n\n总的来说 一个命令由以上几部分组成起来, 就可以将基本的修改、移动操作变得更加强大\n\n### 文本对象类型\n\n以下为一些常用的文本对象类型\n\n* iw inner word\n* aw a word\n* iW inner WORD\n* aW a WORD\n* is inner sentence\n* as a sentence\n* ip inner paragraph\n* ap a paragraph\n* it inner tag\n* at a tag\n* i  ( or i) inner block\n* a  ( or a) a block\n* i  < or i> inner block\n* a  < or a> a block\n* i  { or i} inner block\n* a  { or a} a block\n* i  [ or i] inner block\n* a  [ or a] a block\n* i  inner block\n* a  a block\n* i\\` inner block\n* a\\` a block\n\n从列表中可以看出, _text objects_ 不仅可以匹配单词句子, 还可以匹配到括号等变成中经常会用到的\n符号, 数量使用的话会相当方便\n\n### 举例\n\n#### 普通文本\n\n`diw` 或 `daw` 删除当前选中的单词\n\n其中 _d_ 指 __commond__ , 而 _iw_ 则是一个单词类型的文本对象\n\n注意 `diw` 只会删除单词, 而 `daw` 会同时删除单词旁边的空格, 这是因为\n\n_iw_ 表示 _inner word_ 而 _aw_ 表示 _a word_ , 它不仅会选中单词, 还会选中旁边的空格\n\n#### 程序文本\n\n如下 _html_ 代码中, 使用 `cit` 命令可以快速修改两个tag之间的内容\n\n```html\n<div>\n  <p>hello world!</p>\n</div>\n```\n\nOperator-Pending\n----------------\n\n_Operator-Pending_ 中的Operaotr就是上文中的 __commond__,\n配上 _text-object_ 或者一个 _movement_ 就构成了一个完成的命令\n\n### Movement 映射\n\nVIM 允许将命令中的 _movement_ 映射到其他按键, 如\n\n```viml\n:onoremap p i(\n```\n\n将 `i('` 映射到按键p上, 也就是说 `dp` 等价于 `di(`, 即删除括号中的内容\n\n第二个例子:\n\n```viml\n:onoremap b /return<cr>\n```\n\n执行 `db`, VIM会删除所有下一个 `return` 之间的内容\n\n第三个例子:\n\n```viml\n:onoremap in( :<c-u>normal! f(vi(<cr>\n```\n\n执行 `din(` 会删除当前光标所在的后一对 () 中的内容, 其中用到了 _normal!_\n来模拟命令, 关键点就是 `f(` 这个命令移动到最近的 `(` 然后通过 `vi(` 选中下一个 `)`\n之间的内容\n\n[bookurl]: 'http://learnvimscriptthehardway.stevelosh.com/'\n[operator-padding]: 'http://learnvimscriptthehardway.stevelosh.com/chapters/15.html'\n[text-objects]: 'https://blog.carbonfive.com/2011/10/17/vim-text-objects-the-definitive-guide/'\n","source":"_posts/vim-operator-pending-md.md","raw":"---\ntitle: VIM中的Operator-Pending\ndate: 2018-02-04 16:37:17\ntags: vim\n---\n\n关于VIM中的Operator-Pending映射\n=============================\n\nVIM已经用了有一年了, 但是这一年来基本上只是用到了最基本的功能, 并没有提高很多自己的码字效率,\n插件倒是装了一堆却并没有理解为什么,\n使用着强大的工具却不了解其运作原理总归让人有点不安, 所以趁这两天准备把VIM的基本运作方式搞搞清楚, 顺便给自己的 _.vimrc_ 瘦个身。\n\n首先, 看的是在线版本的 [Learn Vim The Hard Way][bookurl]\n\n前几章关于 _基本设置_ , _文件类型相关设置_ , _按键映射_ 方面的章节都还好, 到 [operator-padding][operator-padding]\n这一章就有点看不懂了, 主要是因为 _text-objects_ 有些不明白, 因此又看了另一篇 [博客][text-objects],\n搞懂了 _text-objects_ 之后再来看就简单多了。\n\nText-Objects\n-------------\n\nVIM中的 _text-objects_ 是更高效得操作单词、句子、段落的一个作用域对象, 称为 __文本对象__\n\n首先需要了解VIM的命令结构\n\nVIM中的命令结构如下\n\n```viml\n<number><command><text object or motion>\n```\n\n* __number__ 是指作用的文本对象数量, 它是可选的, 并且可以在之前或者之后出现\n\n* __commond__ 对文本对象的操作, 如删除、复制等, 它也是可选的, 但如果不指定则该命令就\n失去了编辑能力\n\n* __text objects or motion__ 指文本对象的作用域, 如一个单词(w), 一句话(s), 或一个段落(p)\n\n总的来说 一个命令由以上几部分组成起来, 就可以将基本的修改、移动操作变得更加强大\n\n### 文本对象类型\n\n以下为一些常用的文本对象类型\n\n* iw inner word\n* aw a word\n* iW inner WORD\n* aW a WORD\n* is inner sentence\n* as a sentence\n* ip inner paragraph\n* ap a paragraph\n* it inner tag\n* at a tag\n* i  ( or i) inner block\n* a  ( or a) a block\n* i  < or i> inner block\n* a  < or a> a block\n* i  { or i} inner block\n* a  { or a} a block\n* i  [ or i] inner block\n* a  [ or a] a block\n* i  inner block\n* a  a block\n* i\\` inner block\n* a\\` a block\n\n从列表中可以看出, _text objects_ 不仅可以匹配单词句子, 还可以匹配到括号等变成中经常会用到的\n符号, 数量使用的话会相当方便\n\n### 举例\n\n#### 普通文本\n\n`diw` 或 `daw` 删除当前选中的单词\n\n其中 _d_ 指 __commond__ , 而 _iw_ 则是一个单词类型的文本对象\n\n注意 `diw` 只会删除单词, 而 `daw` 会同时删除单词旁边的空格, 这是因为\n\n_iw_ 表示 _inner word_ 而 _aw_ 表示 _a word_ , 它不仅会选中单词, 还会选中旁边的空格\n\n#### 程序文本\n\n如下 _html_ 代码中, 使用 `cit` 命令可以快速修改两个tag之间的内容\n\n```html\n<div>\n  <p>hello world!</p>\n</div>\n```\n\nOperator-Pending\n----------------\n\n_Operator-Pending_ 中的Operaotr就是上文中的 __commond__,\n配上 _text-object_ 或者一个 _movement_ 就构成了一个完成的命令\n\n### Movement 映射\n\nVIM 允许将命令中的 _movement_ 映射到其他按键, 如\n\n```viml\n:onoremap p i(\n```\n\n将 `i('` 映射到按键p上, 也就是说 `dp` 等价于 `di(`, 即删除括号中的内容\n\n第二个例子:\n\n```viml\n:onoremap b /return<cr>\n```\n\n执行 `db`, VIM会删除所有下一个 `return` 之间的内容\n\n第三个例子:\n\n```viml\n:onoremap in( :<c-u>normal! f(vi(<cr>\n```\n\n执行 `din(` 会删除当前光标所在的后一对 () 中的内容, 其中用到了 _normal!_\n来模拟命令, 关键点就是 `f(` 这个命令移动到最近的 `(` 然后通过 `vi(` 选中下一个 `)`\n之间的内容\n\n[bookurl]: 'http://learnvimscriptthehardway.stevelosh.com/'\n[operator-padding]: 'http://learnvimscriptthehardway.stevelosh.com/chapters/15.html'\n[text-objects]: 'https://blog.carbonfive.com/2011/10/17/vim-text-objects-the-definitive-guide/'\n","slug":"vim-operator-pending-md","published":1,"updated":"2018-02-05T15:26:58.223Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdr5rhpf00026h2j1ulq1l9g","content":"<h1 id=\"关于VIM中的Operator-Pending映射\"><a href=\"#关于VIM中的Operator-Pending映射\" class=\"headerlink\" title=\"关于VIM中的Operator-Pending映射\"></a>关于VIM中的Operator-Pending映射</h1><p>VIM已经用了有一年了, 但是这一年来基本上只是用到了最基本的功能, 并没有提高很多自己的码字效率,<br>插件倒是装了一堆却并没有理解为什么,<br>使用着强大的工具却不了解其运作原理总归让人有点不安, 所以趁这两天准备把VIM的基本运作方式搞搞清楚, 顺便给自己的 <em>.vimrc</em> 瘦个身。</p>\n<p>首先, 看的是在线版本的 <a href=\"&#39;http://learnvimscriptthehardway.stevelosh.com/&#39;\">Learn Vim The Hard Way</a></p>\n<p>前几章关于 <em>基本设置</em> , <em>文件类型相关设置</em> , <em>按键映射</em> 方面的章节都还好, 到 <a href=\"&#39;http://learnvimscriptthehardway.stevelosh.com/chapters/15.html&#39;\">operator-padding</a><br>这一章就有点看不懂了, 主要是因为 <em>text-objects</em> 有些不明白, 因此又看了另一篇 <a href=\"&#39;https://blog.carbonfive.com/2011/10/17/vim-text-objects-the-definitive-guide/&#39;\">博客</a>,<br>搞懂了 <em>text-objects</em> 之后再来看就简单多了。</p>\n<h2 id=\"Text-Objects\"><a href=\"#Text-Objects\" class=\"headerlink\" title=\"Text-Objects\"></a>Text-Objects</h2><p>VIM中的 <em>text-objects</em> 是更高效得操作单词、句子、段落的一个作用域对象, 称为 <strong>文本对象</strong></p>\n<p>首先需要了解VIM的命令结构</p>\n<p>VIM中的命令结构如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;number&gt;&lt;command&gt;&lt;text object or motion&gt;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p><strong>number</strong> 是指作用的文本对象数量, 它是可选的, 并且可以在之前或者之后出现</p>\n</li>\n<li><p><strong>commond</strong> 对文本对象的操作, 如删除、复制等, 它也是可选的, 但如果不指定则该命令就<br>失去了编辑能力</p>\n</li>\n<li><p><strong>text objects or motion</strong> 指文本对象的作用域, 如一个单词(w), 一句话(s), 或一个段落(p)</p>\n</li>\n</ul>\n<p>总的来说 一个命令由以上几部分组成起来, 就可以将基本的修改、移动操作变得更加强大</p>\n<h3 id=\"文本对象类型\"><a href=\"#文本对象类型\" class=\"headerlink\" title=\"文本对象类型\"></a>文本对象类型</h3><p>以下为一些常用的文本对象类型</p>\n<ul>\n<li>iw inner word</li>\n<li>aw a word</li>\n<li>iW inner WORD</li>\n<li>aW a WORD</li>\n<li>is inner sentence</li>\n<li>as a sentence</li>\n<li>ip inner paragraph</li>\n<li>ap a paragraph</li>\n<li>it inner tag</li>\n<li>at a tag</li>\n<li>i  ( or i) inner block</li>\n<li>a  ( or a) a block</li>\n<li>i  &lt; or i&gt; inner block</li>\n<li>a  &lt; or a&gt; a block</li>\n<li>i  { or i} inner block</li>\n<li>a  { or a} a block</li>\n<li>i  [ or i] inner block</li>\n<li>a  [ or a] a block</li>\n<li>i  inner block</li>\n<li>a  a block</li>\n<li>i` inner block</li>\n<li>a` a block</li>\n</ul>\n<p>从列表中可以看出, <em>text objects</em> 不仅可以匹配单词句子, 还可以匹配到括号等变成中经常会用到的<br>符号, 数量使用的话会相当方便</p>\n<h3 id=\"举例\"><a href=\"#举例\" class=\"headerlink\" title=\"举例\"></a>举例</h3><h4 id=\"普通文本\"><a href=\"#普通文本\" class=\"headerlink\" title=\"普通文本\"></a>普通文本</h4><p><code>diw</code> 或 <code>daw</code> 删除当前选中的单词</p>\n<p>其中 <em>d</em> 指 <strong>commond</strong> , 而 <em>iw</em> 则是一个单词类型的文本对象</p>\n<p>注意 <code>diw</code> 只会删除单词, 而 <code>daw</code> 会同时删除单词旁边的空格, 这是因为</p>\n<p><em>iw</em> 表示 <em>inner word</em> 而 <em>aw</em> 表示 <em>a word</em> , 它不仅会选中单词, 还会选中旁边的空格</p>\n<h4 id=\"程序文本\"><a href=\"#程序文本\" class=\"headerlink\" title=\"程序文本\"></a>程序文本</h4><p>如下 <em>html</em> 代码中, 使用 <code>cit</code> 命令可以快速修改两个tag之间的内容</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>hello world!<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"Operator-Pending\"><a href=\"#Operator-Pending\" class=\"headerlink\" title=\"Operator-Pending\"></a>Operator-Pending</h2><p><em>Operator-Pending</em> 中的Operaotr就是上文中的 <strong>commond</strong>,<br>配上 <em>text-object</em> 或者一个 <em>movement</em> 就构成了一个完成的命令</p>\n<h3 id=\"Movement-映射\"><a href=\"#Movement-映射\" class=\"headerlink\" title=\"Movement 映射\"></a>Movement 映射</h3><p>VIM 允许将命令中的 <em>movement</em> 映射到其他按键, 如</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:onoremap p i(</span><br></pre></td></tr></table></figure>\n<p>将 <code>i(&#39;</code> 映射到按键p上, 也就是说 <code>dp</code> 等价于 <code>di(</code>, 即删除括号中的内容</p>\n<p>第二个例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:onoremap b /return&lt;cr&gt;</span><br></pre></td></tr></table></figure>\n<p>执行 <code>db</code>, VIM会删除所有下一个 <code>return</code> 之间的内容</p>\n<p>第三个例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:onoremap in( :&lt;c-u&gt;normal! f(vi(&lt;cr&gt;</span><br></pre></td></tr></table></figure>\n<p>执行 <code>din(</code> 会删除当前光标所在的后一对 () 中的内容, 其中用到了 <em>normal!</em><br>来模拟命令, 关键点就是 <code>f(</code> 这个命令移动到最近的 <code>(</code> 然后通过 <code>vi(</code> 选中下一个 <code>)</code><br>之间的内容</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"关于VIM中的Operator-Pending映射\"><a href=\"#关于VIM中的Operator-Pending映射\" class=\"headerlink\" title=\"关于VIM中的Operator-Pending映射\"></a>关于VIM中的Operator-Pending映射</h1><p>VIM已经用了有一年了, 但是这一年来基本上只是用到了最基本的功能, 并没有提高很多自己的码字效率,<br>插件倒是装了一堆却并没有理解为什么,<br>使用着强大的工具却不了解其运作原理总归让人有点不安, 所以趁这两天准备把VIM的基本运作方式搞搞清楚, 顺便给自己的 <em>.vimrc</em> 瘦个身。</p>\n<p>首先, 看的是在线版本的 <a href=\"&#39;http://learnvimscriptthehardway.stevelosh.com/&#39;\">Learn Vim The Hard Way</a></p>\n<p>前几章关于 <em>基本设置</em> , <em>文件类型相关设置</em> , <em>按键映射</em> 方面的章节都还好, 到 <a href=\"&#39;http://learnvimscriptthehardway.stevelosh.com/chapters/15.html&#39;\">operator-padding</a><br>这一章就有点看不懂了, 主要是因为 <em>text-objects</em> 有些不明白, 因此又看了另一篇 <a href=\"&#39;https://blog.carbonfive.com/2011/10/17/vim-text-objects-the-definitive-guide/&#39;\">博客</a>,<br>搞懂了 <em>text-objects</em> 之后再来看就简单多了。</p>\n<h2 id=\"Text-Objects\"><a href=\"#Text-Objects\" class=\"headerlink\" title=\"Text-Objects\"></a>Text-Objects</h2><p>VIM中的 <em>text-objects</em> 是更高效得操作单词、句子、段落的一个作用域对象, 称为 <strong>文本对象</strong></p>\n<p>首先需要了解VIM的命令结构</p>\n<p>VIM中的命令结构如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;number&gt;&lt;command&gt;&lt;text object or motion&gt;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p><strong>number</strong> 是指作用的文本对象数量, 它是可选的, 并且可以在之前或者之后出现</p>\n</li>\n<li><p><strong>commond</strong> 对文本对象的操作, 如删除、复制等, 它也是可选的, 但如果不指定则该命令就<br>失去了编辑能力</p>\n</li>\n<li><p><strong>text objects or motion</strong> 指文本对象的作用域, 如一个单词(w), 一句话(s), 或一个段落(p)</p>\n</li>\n</ul>\n<p>总的来说 一个命令由以上几部分组成起来, 就可以将基本的修改、移动操作变得更加强大</p>\n<h3 id=\"文本对象类型\"><a href=\"#文本对象类型\" class=\"headerlink\" title=\"文本对象类型\"></a>文本对象类型</h3><p>以下为一些常用的文本对象类型</p>\n<ul>\n<li>iw inner word</li>\n<li>aw a word</li>\n<li>iW inner WORD</li>\n<li>aW a WORD</li>\n<li>is inner sentence</li>\n<li>as a sentence</li>\n<li>ip inner paragraph</li>\n<li>ap a paragraph</li>\n<li>it inner tag</li>\n<li>at a tag</li>\n<li>i  ( or i) inner block</li>\n<li>a  ( or a) a block</li>\n<li>i  &lt; or i&gt; inner block</li>\n<li>a  &lt; or a&gt; a block</li>\n<li>i  { or i} inner block</li>\n<li>a  { or a} a block</li>\n<li>i  [ or i] inner block</li>\n<li>a  [ or a] a block</li>\n<li>i  inner block</li>\n<li>a  a block</li>\n<li>i` inner block</li>\n<li>a` a block</li>\n</ul>\n<p>从列表中可以看出, <em>text objects</em> 不仅可以匹配单词句子, 还可以匹配到括号等变成中经常会用到的<br>符号, 数量使用的话会相当方便</p>\n<h3 id=\"举例\"><a href=\"#举例\" class=\"headerlink\" title=\"举例\"></a>举例</h3><h4 id=\"普通文本\"><a href=\"#普通文本\" class=\"headerlink\" title=\"普通文本\"></a>普通文本</h4><p><code>diw</code> 或 <code>daw</code> 删除当前选中的单词</p>\n<p>其中 <em>d</em> 指 <strong>commond</strong> , 而 <em>iw</em> 则是一个单词类型的文本对象</p>\n<p>注意 <code>diw</code> 只会删除单词, 而 <code>daw</code> 会同时删除单词旁边的空格, 这是因为</p>\n<p><em>iw</em> 表示 <em>inner word</em> 而 <em>aw</em> 表示 <em>a word</em> , 它不仅会选中单词, 还会选中旁边的空格</p>\n<h4 id=\"程序文本\"><a href=\"#程序文本\" class=\"headerlink\" title=\"程序文本\"></a>程序文本</h4><p>如下 <em>html</em> 代码中, 使用 <code>cit</code> 命令可以快速修改两个tag之间的内容</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>hello world!<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"Operator-Pending\"><a href=\"#Operator-Pending\" class=\"headerlink\" title=\"Operator-Pending\"></a>Operator-Pending</h2><p><em>Operator-Pending</em> 中的Operaotr就是上文中的 <strong>commond</strong>,<br>配上 <em>text-object</em> 或者一个 <em>movement</em> 就构成了一个完成的命令</p>\n<h3 id=\"Movement-映射\"><a href=\"#Movement-映射\" class=\"headerlink\" title=\"Movement 映射\"></a>Movement 映射</h3><p>VIM 允许将命令中的 <em>movement</em> 映射到其他按键, 如</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:onoremap p i(</span><br></pre></td></tr></table></figure>\n<p>将 <code>i(&#39;</code> 映射到按键p上, 也就是说 <code>dp</code> 等价于 <code>di(</code>, 即删除括号中的内容</p>\n<p>第二个例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:onoremap b /return&lt;cr&gt;</span><br></pre></td></tr></table></figure>\n<p>执行 <code>db</code>, VIM会删除所有下一个 <code>return</code> 之间的内容</p>\n<p>第三个例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:onoremap in( :&lt;c-u&gt;normal! f(vi(&lt;cr&gt;</span><br></pre></td></tr></table></figure>\n<p>执行 <code>din(</code> 会删除当前光标所在的后一对 () 中的内容, 其中用到了 <em>normal!</em><br>来模拟命令, 关键点就是 <code>f(</code> 这个命令移动到最近的 <code>(</code> 然后通过 <code>vi(</code> 选中下一个 <code>)</code><br>之间的内容</p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cjdr5rhpe00016h2jtcg5pysp","tag_id":"cjdr5rhpg00036h2j16fi7ark","_id":"cjdr5rhpj00056h2j65vrl72m"},{"post_id":"cjdr5rhpf00026h2j1ulq1l9g","tag_id":"cjdr5rhpj00046h2jsbdivjkg","_id":"cjdr5rhpk00066h2jmckwtcnz"},{"post_id":"cjdr5rhja00006h2jv7imut1i","tag_id":"cjdr63ozc0000bd2jzdcdyxe8","_id":"cjdr63ozf0001bd2jidfr4s1o"}],"Tag":[{"name":"mysql","_id":"cjdr5rhpg00036h2j16fi7ark"},{"name":"vim","_id":"cjdr5rhpj00046h2jsbdivjkg"},{"name":"java","_id":"cjdr63ozc0000bd2jzdcdyxe8"}]}}