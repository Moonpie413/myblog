<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WXH</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-02-17T09:35:24.967Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>wangxinhua</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>并发编程笔记 (一)</title>
    <link href="http://yoursite.com/2018/02/14/concurrency-notes/"/>
    <id>http://yoursite.com/2018/02/14/concurrency-notes/</id>
    <published>2018-02-14T14:45:33.000Z</published>
    <updated>2018-02-17T09:35:24.967Z</updated>
    
    <content type="html"><![CDATA[<h2 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h2><p>增强了同步同步容器类, </p><h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><ul><li>在迭代时不需要加锁</li><li>具有若一致性, 而不是即时失败</li></ul><h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h3><ul><li>安全读取, 写入时复制<ul><li>保留一个指向底层基础数组的索引, 它不会被修改, 因此其他线程可以安全迭代</li></ul></li></ul><h2 id="处理InterruptedException"><a href="#处理InterruptedException" class="headerlink" title="处理InterruptedException"></a>处理InterruptedException</h2><p>抛出该异常表示该方法可能长时间阻塞</p><ul><li>向调用层抛出</li><li>调用 <code>Thread.currentThread().interrput()</code> 中断当前线程</li></ul><h2 id="闭锁"><a href="#闭锁" class="headerlink" title="闭锁"></a>闭锁</h2><p>用于控制多个线程在同一时间点做某件事情, <code>awati()</code> 方法调用后直到该 <code>countDownLatch</code> 值<br>为1, 否则一直阻塞</p><h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>信号量管理一组 <strong>许可</strong>, 执行操作时首先通过 <code>acquire()</code> 获取许可, 执行完后再通过 <code>release()</code><br>返回许可, 当没有许可时 <code>acquire()</code> 会阻塞或抛出异常</p><p><strong>例子: 通过信号量实现有界容器</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoundedSet</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;T&gt; innerSet;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Semaphore sem;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">BoundedSet</span><span class="params">(<span class="keyword">int</span> bound)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 封装为同步容器, 多个线程会添加或删除</span></span><br><span class="line">    <span class="keyword">this</span>.innerSet = Collections.synchronizedSet(<span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">    <span class="keyword">this</span>.sem = <span class="keyword">new</span> Semaphore(bound);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(T t)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 添加时若容器已满则阻塞</span></span><br><span class="line">    sem.acquire();</span><br><span class="line">    <span class="keyword">return</span> innerSet.add(t);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> removed = innerSet.remove(t);</span><br><span class="line">    <span class="keyword">if</span> (removed) &#123;</span><br><span class="line">      <span class="comment">// 删除时若删除成功则返回许可</span></span><br><span class="line">      sem.release();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> removed;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 测试, 先充满容器, 再添加元素时应该阻塞, 两秒后删除某个元素后</span></span><br><span class="line">    <span class="comment">// 应该可以继续正常添加</span></span><br><span class="line">    <span class="keyword">int</span> bound = <span class="number">10</span>;</span><br><span class="line">    BoundedSet&lt;Integer&gt; boundedSet = <span class="keyword">new</span> BoundedSet&lt;&gt;(bound);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">      boundedSet.add(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      boundedSet.remove(<span class="number">8</span>);</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"start adding 11"</span>);</span><br><span class="line">    boundedSet.add(<span class="number">10</span>);</span><br><span class="line">    System.out.println(<span class="string">"this should appear after 2 seconds"</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="栅栏barrier"><a href="#栅栏barrier" class="headerlink" title="栅栏barrier"></a>栅栏barrier</h2><p>可以确保在并行计算中, 每个线程都执行完第K步操作后才进入第K+1步</p><h3 id="与闭锁的区别"><a href="#与闭锁的区别" class="headerlink" title="与闭锁的区别"></a>与闭锁的区别</h3><p>所有线程必须同时到 <strong>栅栏的位置</strong> 才可以继续运行<br>这个 <strong>位置</strong> 可以由线程自己调用</p><h2 id="Memorzer缓存实例"><a href="#Memorzer缓存实例" class="headerlink" title="Memorzer缓存实例"></a>Memorzer缓存实例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Memoizer</span>&lt;<span class="title">A</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Computable</span>&lt;<span class="title">A</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;A, Future&lt;V&gt;&gt; cache</span><br><span class="line">      = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Computable&lt;A, V&gt; c;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Memoizer</span><span class="params">(Computable&lt;A, V&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.c = c;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> V <span class="title">compute</span><span class="params">(A a)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">      Future&lt;V&gt; f = cache.get(a);</span><br><span class="line">      <span class="comment">// 缓存中没有值</span></span><br><span class="line">      <span class="keyword">if</span> (f == <span class="keyword">null</span>) &#123;</span><br><span class="line">        FutureTask&lt;V&gt; ft = <span class="keyword">new</span> FutureTask&lt;&gt;(() -&gt; c.compute(a));</span><br><span class="line">        <span class="comment">// 这时其他线程可能已经放入了future</span></span><br><span class="line">        f = cache.putIfAbsent(a, ft);</span><br><span class="line">        <span class="comment">// 如果已经有future了则不替换 (putIfAbsent是原子操作)</span></span><br><span class="line">        <span class="keyword">if</span> (f == <span class="keyword">null</span>) &#123;</span><br><span class="line">          f = ft;</span><br><span class="line">          <span class="comment">// 否则运行future</span></span><br><span class="line">          <span class="comment">// 可保证future只运行一次</span></span><br><span class="line">          ft.run();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 只要有线程在计算则会阻塞 (因为不会被替换)</span></span><br><span class="line">        <span class="keyword">return</span> f.get();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CompletionService"><a href="#CompletionService" class="headerlink" title="CompletionService"></a>CompletionService</h2><p>将 <em>Executor</em> 与 <em>BlockingQueue</em> 结合到一起, 可以通过 <code>take()</code> 异步获取已经完成的任务</p><h2 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h2><p>调用中断不意味着立即停止, 而只是发起了停止请求， 在适当的时候执行中断, 并做好清理工作</p><p>可以通过 <code>Thread.currentThread.isInterrupted</code> 方法判断当前线程是否已经收到了中断请求</p><h3 id="响应中断"><a href="#响应中断" class="headerlink" title="响应中断"></a>响应中断</h3><p>有两种策略可以用于处理 <code>InterruptedException</code></p><ol><li>抛出中断异常</li><li><strong>恢复</strong> 中断状态, 使得上层代码可以处理中断</li></ol><p>关于第二中方式, 刚看书的时候并不明白什么叫 <em>恢复中断</em>,<br>查了一下找到了这篇<a href="https://stackoverflow.com/questions/4906799/why-invoke-thread-currentthread-interrupt-in-a-catch-interruptexception-block" target="_blank" rel="noopener">解释</a></p><p>在捕获 <code>InterruptedException</code> 后会清除当前的中断状态, 所以外部线程无法看到该线程是否中断,<br>因此才需要调用<code>Thread.currentThread().interrupt()</code> 来重新设置线程的中断状态, 从而使外部线程可以处理</p><p><strong>如下面这个例子</strong></p><p>如果在异常捕获后没有设置当前线程的 <code>interrupt</code>,<br>那么在一次中断后当前线程在调用 <code>sleep</code> 或者 <code>take</code><br>这样的阻塞方法时仍然会继续阻塞, 因为它们看不到当前线程的已阻塞标志</p><p>而手动调用 <code>Thread.currentThread.isInterrupted</code> 后在下次循环时 <code>sleep</code> 或者<br><code>take</code> 方法可以看到该线程已经中断, 因此会直接再次抛出中断异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueInterruptTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> BlockingQueue&lt;Integer&gt; QUEUE</span><br><span class="line">      = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 该线程会在take或sleep处阻塞直到外部调用中断</span></span><br><span class="line">    Thread t = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          System.out.println(<span class="string">"ignore sleep interrupt"</span>);</span><br><span class="line">          <span class="comment">// 不显式调用该方法则下次循环到该处还会继续阻塞</span></span><br><span class="line">          <span class="comment">// 因为sleep看不到该线程已被中断</span></span><br><span class="line">          <span class="comment">// Thread.currentThread().interrupt();</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"still looping..."</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          QUEUE.take();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          System.out.println(<span class="string">"take interrupt"</span>);</span><br><span class="line">          <span class="comment">// Thread.currentThread().interrupt();</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    t.start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动一个线程10秒后中断BlockingQueue的线程</span></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(<span class="string">"interrupt t, status: "</span> + t.isInterrupted());</span><br><span class="line">      t.interrupt();</span><br><span class="line">    &#125;).start();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="处理不可中断的阻塞"><a href="#处理不可中断的阻塞" class="headerlink" title="处理不可中断的阻塞"></a>处理不可中断的阻塞</h3><p>以下几种阻塞操作不会抛出 <code>interruptexception</code>, 因此需要手动调用相关的方法关闭阻塞操作,<br>可以复写线程的 <code>interrput</code> 方法在响应中断时进行相应的处理</p><ul><li>同步/异步 IO 手动调用关闭IO</li><li>获取某个锁而阻塞 通过 <code>lockInterruptibly</code> 中断锁等待</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;并发容器&quot;&gt;&lt;a href=&quot;#并发容器&quot; class=&quot;headerlink&quot; title=&quot;并发容器&quot;&gt;&lt;/a&gt;并发容器&lt;/h2&gt;&lt;p&gt;增强了同步同步容器类, &lt;/p&gt;
&lt;h3 id=&quot;ConcurrentHashMap&quot;&gt;&lt;a href=&quot;#Concurre
      
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>VIM中的Operator-Pending</title>
    <link href="http://yoursite.com/2018/02/04/vim-operator-pending-md/"/>
    <id>http://yoursite.com/2018/02/04/vim-operator-pending-md/</id>
    <published>2018-02-04T08:37:17.000Z</published>
    <updated>2018-02-05T15:26:58.223Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于VIM中的Operator-Pending映射"><a href="#关于VIM中的Operator-Pending映射" class="headerlink" title="关于VIM中的Operator-Pending映射"></a>关于VIM中的Operator-Pending映射</h1><p>VIM已经用了有一年了, 但是这一年来基本上只是用到了最基本的功能, 并没有提高很多自己的码字效率,<br>插件倒是装了一堆却并没有理解为什么,<br>使用着强大的工具却不了解其运作原理总归让人有点不安, 所以趁这两天准备把VIM的基本运作方式搞搞清楚, 顺便给自己的 <em>.vimrc</em> 瘦个身。</p><p>首先, 看的是在线版本的 <a href="&#39;http://learnvimscriptthehardway.stevelosh.com/&#39;">Learn Vim The Hard Way</a></p><p>前几章关于 <em>基本设置</em> , <em>文件类型相关设置</em> , <em>按键映射</em> 方面的章节都还好, 到 <a href="&#39;http://learnvimscriptthehardway.stevelosh.com/chapters/15.html&#39;">operator-padding</a><br>这一章就有点看不懂了, 主要是因为 <em>text-objects</em> 有些不明白, 因此又看了另一篇 <a href="&#39;https://blog.carbonfive.com/2011/10/17/vim-text-objects-the-definitive-guide/&#39;">博客</a>,<br>搞懂了 <em>text-objects</em> 之后再来看就简单多了。</p><h2 id="Text-Objects"><a href="#Text-Objects" class="headerlink" title="Text-Objects"></a>Text-Objects</h2><p>VIM中的 <em>text-objects</em> 是更高效得操作单词、句子、段落的一个作用域对象, 称为 <strong>文本对象</strong></p><p>首先需要了解VIM的命令结构</p><p>VIM中的命令结构如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;number&gt;&lt;command&gt;&lt;text object or motion&gt;</span><br></pre></td></tr></table></figure><ul><li><p><strong>number</strong> 是指作用的文本对象数量, 它是可选的, 并且可以在之前或者之后出现</p></li><li><p><strong>commond</strong> 对文本对象的操作, 如删除、复制等, 它也是可选的, 但如果不指定则该命令就<br>失去了编辑能力</p></li><li><p><strong>text objects or motion</strong> 指文本对象的作用域, 如一个单词(w), 一句话(s), 或一个段落(p)</p></li></ul><p>总的来说 一个命令由以上几部分组成起来, 就可以将基本的修改、移动操作变得更加强大</p><h3 id="文本对象类型"><a href="#文本对象类型" class="headerlink" title="文本对象类型"></a>文本对象类型</h3><p>以下为一些常用的文本对象类型</p><ul><li>iw inner word</li><li>aw a word</li><li>iW inner WORD</li><li>aW a WORD</li><li>is inner sentence</li><li>as a sentence</li><li>ip inner paragraph</li><li>ap a paragraph</li><li>it inner tag</li><li>at a tag</li><li>i  ( or i) inner block</li><li>a  ( or a) a block</li><li>i  &lt; or i&gt; inner block</li><li>a  &lt; or a&gt; a block</li><li>i  { or i} inner block</li><li>a  { or a} a block</li><li>i  [ or i] inner block</li><li>a  [ or a] a block</li><li>i  inner block</li><li>a  a block</li><li>i` inner block</li><li>a` a block</li></ul><p>从列表中可以看出, <em>text objects</em> 不仅可以匹配单词句子, 还可以匹配到括号等变成中经常会用到的<br>符号, 数量使用的话会相当方便</p><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><h4 id="普通文本"><a href="#普通文本" class="headerlink" title="普通文本"></a>普通文本</h4><p><code>diw</code> 或 <code>daw</code> 删除当前选中的单词</p><p>其中 <em>d</em> 指 <strong>commond</strong> , 而 <em>iw</em> 则是一个单词类型的文本对象</p><p>注意 <code>diw</code> 只会删除单词, 而 <code>daw</code> 会同时删除单词旁边的空格, 这是因为</p><p><em>iw</em> 表示 <em>inner word</em> 而 <em>aw</em> 表示 <em>a word</em> , 它不仅会选中单词, 还会选中旁边的空格</p><h4 id="程序文本"><a href="#程序文本" class="headerlink" title="程序文本"></a>程序文本</h4><p>如下 <em>html</em> 代码中, 使用 <code>cit</code> 命令可以快速修改两个tag之间的内容</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>hello world!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Operator-Pending"><a href="#Operator-Pending" class="headerlink" title="Operator-Pending"></a>Operator-Pending</h2><p><em>Operator-Pending</em> 中的Operaotr就是上文中的 <strong>commond</strong>,<br>配上 <em>text-object</em> 或者一个 <em>movement</em> 就构成了一个完成的命令</p><h3 id="Movement-映射"><a href="#Movement-映射" class="headerlink" title="Movement 映射"></a>Movement 映射</h3><p>VIM 允许将命令中的 <em>movement</em> 映射到其他按键, 如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:onoremap p i(</span><br></pre></td></tr></table></figure><p>将 <code>i(&#39;</code> 映射到按键p上, 也就是说 <code>dp</code> 等价于 <code>di(</code>, 即删除括号中的内容</p><p>第二个例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:onoremap b /return&lt;cr&gt;</span><br></pre></td></tr></table></figure><p>执行 <code>db</code>, VIM会删除所有下一个 <code>return</code> 之间的内容</p><p>第三个例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:onoremap in( :&lt;c-u&gt;normal! f(vi(&lt;cr&gt;</span><br></pre></td></tr></table></figure><p>执行 <code>din(</code> 会删除当前光标所在的后一对 () 中的内容, 其中用到了 <em>normal!</em><br>来模拟命令, 关键点就是 <code>f(</code> 这个命令移动到最近的 <code>(</code> 然后通过 <code>vi(</code> 选中下一个 <code>)</code><br>之间的内容</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;关于VIM中的Operator-Pending映射&quot;&gt;&lt;a href=&quot;#关于VIM中的Operator-Pending映射&quot; class=&quot;headerlink&quot; title=&quot;关于VIM中的Operator-Pending映射&quot;&gt;&lt;/a&gt;关于VIM中的Oper
      
    
    </summary>
    
    
      <category term="vim" scheme="http://yoursite.com/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>mysql笔记 (一)</title>
    <link href="http://yoursite.com/2018/02/01/mysql_notes_1/"/>
    <id>http://yoursite.com/2018/02/01/mysql_notes_1/</id>
    <published>2018-02-01T14:59:05.000Z</published>
    <updated>2018-02-01T16:46:23.669Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="#%E5%B1%82%E7%BA%A7%E7%BB%93%E6%9E%84">层级结构</a></li><li><a href="#%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E">存储引擎</a><ul><li><a href="#myisam">MyISAM</a><ul><li><a href="#%E7%B4%A2%E5%BC%95%E6%94%AF%E6%8C%81">索引支持</a></li></ul></li><li><a href="#innodb">InnoDB</a><ul><li><a href="#%E4%B8%BB%E8%A6%81%E7%89%B9%E6%80%A7">主要特性</a></li></ul></li></ul></li><li><a href="#%E6%9D%83%E9%99%90%E7%BA%A7%E5%88%AB">权限级别</a><ul><li><a href="#global-level">Global Level</a></li><li><a href="#database-level">Database Level</a></li><li><a href="#tabel-level">Tabel Level</a></li><li><a href="#column-level">Column Level</a></li><li><a href="#routine-level">Routine Level</a></li><li><a href="#grant">GRANT</a></li></ul></li></ul><h1 id="层级结构"><a href="#层级结构" class="headerlink" title="层级结构"></a>层级结构</h1><p><strong>Sql Layer</strong> 负责查询相关, <strong>Storage Engine Layer</strong> 底层数据存储相关</p><p>将存储与计算分离</p><p><img src="/images/mysql_layer.png" alt="mysql_layer.png"></p><h1 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h1><h2 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h2><h3 id="索引支持"><a href="#索引支持" class="headerlink" title="索引支持"></a>索引支持</h3><ol><li>B-Tree<ul><li>按照 <em>B-Tree</em> 结构存储数据</li></ul></li><li>R-Tree<ul><li>设计用于为存储空间和多维数据的字段做索引 (暂时不是很明白这段话的意思)</li></ul></li><li>Full-Text<ul><li>全文检索, 提高 <em>LIKE</em> 查询的效率</li></ul></li></ol><h2 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h2><h3 id="主要特性"><a href="#主要特性" class="headerlink" title="主要特性"></a>主要特性</h3><ol><li>支持事务安全</li><li>数据多版本读取</li><li>锁定机制改进<ul><li>改变了MyISAM的锁机制实现了行锁</li></ul></li><li>实现外建</li></ol><h1 id="权限级别"><a href="#权限级别" class="headerlink" title="权限级别"></a>权限级别</h1><h2 id="Global-Level"><a href="#Global-Level" class="headerlink" title="Global Level"></a>Global Level</h2><p>全局级别, <strong>拥有最高优先级</strong></p><p><code>*.*</code> 表示全局作用域</p><p>示例:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span>,<span class="keyword">UPDATE</span>,<span class="keyword">DELETE</span>,<span class="keyword">INSERT</span> <span class="keyword">ON</span> *.* <span class="keyword">TO</span> <span class="string">'def'</span>@<span class="string">'localhost'</span>;</span><br></pre></td></tr></table></figure><h2 id="Database-Level"><a href="#Database-Level" class="headerlink" title="Database Level"></a>Database Level</h2><p><code>database.*</code> 表示数据库级别作用域</p><p>示例:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALTER</span> <span class="keyword">ON</span> test.* <span class="keyword">TO</span> <span class="string">'def'</span>@<span class="string">'localhost'</span>;</span><br></pre></td></tr></table></figure><p>也可以先选定数据库, 然后通过 <code>*</code> 来限定作用域为当前数据库, 如:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">USE</span> <span class="keyword">test</span>;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">DROP</span> <span class="keyword">ON</span> * <span class="keyword">TO</span> <span class="string">'def'</span>@<span class="string">'localhost'</span>;</span><br></pre></td></tr></table></figure><p>多个用户可以用逗号隔开:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">CREATE</span> <span class="keyword">ON</span> perf.* <span class="keyword">TO</span> <span class="string">'abc'</span>@<span class="string">'localhost'</span>,<span class="string">'def'</span>@<span class="string">'localhost'</span>;</span><br></pre></td></tr></table></figure><h2 id="Tabel-Level"><a href="#Tabel-Level" class="headerlink" title="Tabel Level"></a>Tabel Level</h2><p><code>database.table</code> 表级别作用域</p><p>示例:</p><p>其中 <em>%</em> 表示通配符</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">INDEX</span> <span class="keyword">ON</span> test.t1 <span class="keyword">TO</span> <span class="string">'abc'</span>@<span class="string">'%.jianzhaoyang.com'</span>;</span><br></pre></td></tr></table></figure><h2 id="Column-Level"><a href="#Column-Level" class="headerlink" title="Column Level"></a>Column Level</h2><p>列级别, 语法与 <em>Table Level</em> 相似, 只是需要在括号中指定列</p><p>示例:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span>(<span class="keyword">id</span>,<span class="keyword">value</span>) <span class="keyword">ON</span> test.t2 <span class="keyword">TO</span> <span class="string">'abc'</span>@<span class="string">'%.jianzhaoyang.com'</span>;</span><br></pre></td></tr></table></figure><h2 id="Routine-Level"><a href="#Routine-Level" class="headerlink" title="Routine Level"></a>Routine Level</h2><p>主要针对 <em>procedure</em> 和 <em>function</em></p><h2 id="GRANT"><a href="#GRANT" class="headerlink" title="GRANT"></a>GRANT</h2><p>特殊权限, 拥有该权限的用户可以将 <strong>自身</strong> 拥有的权限赋予其他用户</p><p>示例:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> ALL <span class="keyword">ON</span> test.t5 <span class="keyword">TO</span> <span class="string">'abc'</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%B1%82%E7%BA%A7%E7%BB%93%E6%9E%84&quot;&gt;层级结构&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E&quot;&gt;存储引擎&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;
      
    
    </summary>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
</feed>
