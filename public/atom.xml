<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WXH</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-03-11T10:44:33.510Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>wangxinhua</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>netty笔记 (三)</title>
    <link href="http://yoursite.com/2018/03/10/netty-notes-3/"/>
    <id>http://yoursite.com/2018/03/10/netty-notes-3/</id>
    <published>2018-03-10T13:42:24.000Z</published>
    <updated>2018-03-11T10:44:33.510Z</updated>
    
    <content type="html"><![CDATA[<p>Netty笔记第三部分</p><a id="more"></a><h2 id="编解码器"><a href="#编解码器" class="headerlink" title="编解码器"></a>编解码器</h2><p>在处理基于流的传输(如TCP/IP)时需要注意netty获取到的数据会暂存在buffer中, 但是在buffer中存储的顺序<br>不一定是真实传输的顺序</p><p>netty可以通过实现编码器/解码器来处理字节数组, 将它们编码/解码成想要的数据类型</p><p>如以下的解码器将字节编码为时间对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.netty.example.time;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeDecoder</span> <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (in.readableBytes() &lt; <span class="number">4</span>) &#123;</span><br><span class="line"><span class="comment">// 凑够四个字节即一个int才可以组成时间</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    out.add(<span class="keyword">new</span> UnixTime(in.readUnsignedInt()));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Http服务器"><a href="#Http服务器" class="headerlink" title="Http服务器"></a>Http服务器</h2><p>通过netty提供的http编解码器, 可以轻松编写出http服务器而不用关心底层实现</p><p><strong>例子:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpServerInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] CONTENT = &#123;<span class="string">'H'</span>, <span class="string">'e'</span>, <span class="string">'l'</span>, <span class="string">'l'</span>, <span class="string">'o'</span>, <span class="string">' '</span>, <span class="string">'W'</span>, <span class="string">'o'</span>, <span class="string">'r'</span>, <span class="string">'l'</span>, <span class="string">'d'</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AsciiString CONTENT_TYPE = AsciiString.cached(<span class="string">"Content-Type"</span>);</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AsciiString CONTENT_LENGTH = AsciiString.cached(<span class="string">"Content-Length"</span>);</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AsciiString CONNECTION = AsciiString.cached(<span class="string">"Connection"</span>);</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AsciiString KEEP_ALIVE = AsciiString.cached(<span class="string">"keep-alive"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> SSL = System.getProperty(<span class="string">"ssl"</span>) != <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> SslContext SSL_CONTEXT;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    SelfSignedCertificate ssc;</span><br><span class="line">    <span class="keyword">if</span> (SSL) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        ssc = <span class="keyword">new</span> SelfSignedCertificate();</span><br><span class="line">        SSL_CONTEXT = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey()).build();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (CertificateException | SSLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> </span>&#123;</span><br><span class="line">    ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">    <span class="comment">// 如果支持HTTPS 则添加https编解码器</span></span><br><span class="line">    <span class="keyword">if</span> (SSL) &#123;</span><br><span class="line">      pipeline.addLast(SSL_CONTEXT.newHandler(ch.alloc()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// netty内置的http编解码器, 同时实现了</span></span><br><span class="line">    <span class="comment">// HttpRequestDecoder 和 HttpResponseEncoder</span></span><br><span class="line">    pipeline.addLast(<span class="keyword">new</span> HttpServerCodec());</span><br><span class="line">    <span class="comment">// 自己实现的服务器实现逻辑, 由于放在解码器之后, 所以处理的已经是</span></span><br><span class="line">    <span class="comment">// 经过解码器处理的httpObject对象</span></span><br><span class="line">    pipeline.addLast(<span class="keyword">new</span> HttpServerHandler());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> HttpRequest) &#123;</span><br><span class="line">        HttpRequest req = (HttpRequest) msg;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> keepAlive = HttpUtil.isKeepAlive(req);</span><br><span class="line">        FullHttpResponse response = <span class="keyword">new</span> DefaultFullHttpResponse(HTTP_1_1, OK,</span><br><span class="line">            Unpooled.wrappedBuffer(CONTENT));</span><br><span class="line">        response.headers().set(CONTENT_TYPE, <span class="string">"text/plain"</span>);</span><br><span class="line">        response.headers().setInt(CONTENT_LENGTH, response.content().readableBytes());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!keepAlive) &#123;</span><br><span class="line">          ctx.write(response)</span><br><span class="line">              .addListener(ChannelFutureListener.CLOSE);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          response.headers().set(CONNECTION, KEEP_ALIVE);</span><br><span class="line">          ctx.write(response);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> </span>&#123;</span><br><span class="line">      cause.printStackTrace();</span><br><span class="line">      ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">      ctx.flush();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Http客户端"><a href="#Http客户端" class="headerlink" title="Http客户端"></a>Http客户端</h2><p>同理, http客户端的例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpClientInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String url;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">HttpClientInitializer</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.url = url;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> </span>&#123;</span><br><span class="line">    ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">    pipeline.addLast(<span class="keyword">new</span> HttpClientCodec());</span><br><span class="line">    pipeline.addLast(<span class="keyword">new</span> HttpClientHandler(url));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpClientHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String url;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HttpClientHandler</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.url = url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">      FullHttpRequest request = <span class="keyword">new</span> DefaultFullHttpRequest(HTTP_1_1, GET, url);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 不设置该行若不手动关闭context则客户端不会自动关闭</span></span><br><span class="line">      <span class="comment">// 相当于服务端关闭</span></span><br><span class="line">      request.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.CLOSE);</span><br><span class="line">      request.headers().set(HttpHeaderNames.HOST, url);</span><br><span class="line">      ctx.writeAndFlush(request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> HttpResponse) &#123;</span><br><span class="line">        HttpResponseStatus status = ((HttpResponse) msg).status();</span><br><span class="line">        <span class="keyword">if</span> (status.code() == <span class="number">200</span>) &#123;</span><br><span class="line">          System.out.println(<span class="string">"request successful!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> HttpContent) &#123;</span><br><span class="line">        ByteBuf buf = ((HttpContent) msg).content();</span><br><span class="line">        System.out.println(buf.toString(CharsetUtil.UTF_8));</span><br><span class="line">        <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> LastHttpContent) &#123;</span><br><span class="line">          ReferenceCountUtil.release(buf);</span><br><span class="line">          ctx.close();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> </span>&#123;</span><br><span class="line">      cause.printStackTrace();</span><br><span class="line">      ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>在编写客户端的时候发现客户端在执行完后并没有关闭, 经过一下午的研究后基本搞懂了netty的关闭过程</p><p>netty的标准模式中经常会出现下面的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ChannelFuture f = b.connect().sync();</span><br><span class="line">f.channel().closeFuture().sync();</span><br></pre></td></tr></table></figure><p>其中<code>sync()</code> 表示该方法同步执行, 通过阅读源码发现<code>sync()</code>中会调用当前线程的<code>wait()</code>以此来实现同步<br>原先http客户端运行完没有自动关闭就是因为主线程一直等待, 那么主线程何时会停止等待呢</p><p>官方文档对 <code>closeFuture()</code> 的注释如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Returns the &#123;<span class="doctag">@link</span> ChannelFuture&#125; which will be notified when this</span></span><br><span class="line"><span class="comment">* * channel is closed.  This method always returns the same future instance.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">ChannelFuture <span class="title">closeFuture</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>也就是说连接结束或异常的时候, 主线程才能继续执行</p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>第一次尝试是在 <code>HttpClientHandler</code> 的 <code>channelRead()</code> 中调用 <code>ctx.close()</code>, 这确实可行, 客户端<br>运行完后就关闭了, 但是又想了一下为什么之前的echoClient不调用该方法也能自动关闭?之后google了一下又看了<br>netty的官方 <code>HttpSnoopClient</code> 示例, 才想起来服务端有这样的代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!keepAlive) &#123;</span><br><span class="line">  ctx.write(response)</span><br><span class="line">      .addListener(ChannelFutureListener.CLOSE);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  response.headers().set(CONNECTION, KEEP_ALIVE);</span><br><span class="line">  ctx.write(response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说如果客户端是长连接那服务端不会关闭这个连接, 对比了一下自己的实现和官方的实现, 果然是自己没有设置关闭长连接,<br>加入了如下代码后就正常了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.CLOSE);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Netty笔记第三部分&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>netty笔记 (二)</title>
    <link href="http://yoursite.com/2018/02/27/netty-notes-2/"/>
    <id>http://yoursite.com/2018/02/27/netty-notes-2/</id>
    <published>2018-02-27T12:36:51.000Z</published>
    <updated>2018-03-04T16:16:48.770Z</updated>
    
    <content type="html"><![CDATA[<p>Netty笔记第二部分</p><a id="more"></a><h2 id="ByteBuf与ByteBuffer的不同点"><a href="#ByteBuf与ByteBuffer的不同点" class="headerlink" title="ByteBuf与ByteBuffer的不同点"></a>ByteBuf与ByteBuffer的不同点</h2><p>Netty提供了自己的ByteBuf实现, 跟JDK中ByteBuffer主要有如下的不同点</p><ol><li>ByteBuf支持动态扩容 (若不指定长度则默认长度为Integer.MAX_VALUE)</li><li>读写分离, 不需要 <code>clear()</code> 及 <code>flip()</code> 方法来改变读写模式</li><li>支持引用计数</li><li>支持池化</li></ol><p>通过 <code>hasArray()</code> 方法区分直接缓冲区还是堆缓冲区</p><p>直接缓冲区内部空间将驻留在会被垃圾回收的堆内存之外,<br>而堆缓冲区实现底层数据保存在一个数组中, 如果 <code>hasArray()</code> 返回 <code>true</code> 则可以获取数组遍历数据</p><h2 id="事件传播路径"><a href="#事件传播路径" class="headerlink" title="事件传播路径"></a>事件传播路径</h2><p>调用channelHandlerContext中 <code>fire</code> 开头的方法时会调用channelPipeLine中的下一个handler</p><h3 id="调用channelHandlerContext与调用channelPipeLine的不同"><a href="#调用channelHandlerContext与调用channelPipeLine的不同" class="headerlink" title="调用channelHandlerContext与调用channelPipeLine的不同"></a>调用channelHandlerContext与调用channelPipeLine的不同</h3><p>在channelHandlerContext中调用方法(如write)将会让事件当前handler开始传播,<br>而调用channelPipeLine中的方法会让事件从头部开始流动</p><h2 id="Netty线程模型"><a href="#Netty线程模型" class="headerlink" title="Netty线程模型"></a>Netty线程模型</h2><p>在笔记一中说明了Netty服务器启动时需要两个EventLoopGroop(通常只有一个EventLoop), 第一个Group(即BossGroup)负责客户端请求,<br>并打开channel, 然后将channel交给第二个workerGroup处理, 在workerGroup中存在多个EventLoop,<br><strong>每个EventLoop可以处理多个channel, 每个channel由一个EventLoop处理所以事件</strong>, 由于一个EventLoop及对应一个线程, 所有在channel<br>的生命周期内对它的操作都是线程安全的</p><p><strong>图例: NIO分配的Eventloop模型</strong></p><p><img src="/images/eventloop_thread.png" alt="eventloop.png"></p><h2 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a>EventLoop</h2><p>Netty的EventLoop继承了ScheduledExecutorService, 及实现了自定义的ThreadPoolExecutor(在ScheduledExecutorService基础上扩展)</p><p>通过channel可以获取到当前分配给该个channel的EventLoop, 由于EventLoop继承了ScheduledExecutorService, 所以<br>可以通过它调用ScheduledExecutorService中的所有方法, 即可以给它提交任务(或定时任务),</p><p>Eventloop被称为事件循环, 并且前面讲到了它对应一个线程, 通过查看源码找出看出这个入口在哪里</p><p>NIO中EventLoop的实现为NioEventLoop, 它是一个 <em>exctor</em> 所有它的入口应该为 <code>execute()</code> 方法, 这个方法继承自<br><code>SingleThreadEventExecutor</code>, 代码为:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"task"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 进行了判断, 如果当前线程不是eventloop线程</span></span><br><span class="line">        <span class="comment">// 则会调用startThread启动自身的线程, 并把任务提交到队列</span></span><br><span class="line">        <span class="comment">// 下次任务循环时从队列中取出, 并由自己的线程执行, 以此保证并发安全性</span></span><br><span class="line">        <span class="keyword">boolean</span> inEventLoop = inEventLoop();</span><br><span class="line">        <span class="keyword">if</span> (inEventLoop) &#123;</span><br><span class="line">            addTask(task);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            startThread();</span><br><span class="line">            addTask(task);</span><br><span class="line">            <span class="keyword">if</span> (isShutdown() &amp;&amp; removeTask(task)) &#123;</span><br><span class="line">                reject();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!addTaskWakesUp &amp;&amp; wakesUpForTask(task)) &#123;</span><br><span class="line">            wakeup(inEventLoop);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里的 <code>startThread()</code> 方法就是自身线程的初始化方法, 最后的工作在 <code>doStartThread()</code> 中进行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doStartThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> thread == <span class="keyword">null</span>;</span><br><span class="line">        executor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                thread = Thread.currentThread();</span><br><span class="line">                <span class="keyword">if</span> (interrupted) &#123;</span><br><span class="line">                    thread.interrupt();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">                updateLastExecutionTime();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    SingleThreadEventExecutor.<span class="keyword">this</span>.run();</span><br><span class="line">                    success = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    logger.warn(<span class="string">"Unexpected exception from an event executor: "</span>, t);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 清理工作, 省略...</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p>通过跟踪代码， 自身启动了一个thread, 跟前面的理论吻合, 关键点为调用了 <code>run()</code> 方法, 发现这个 <code>run()</code><br>方法为抽象方法, 由子类实现, 在 <code>NioEventLoop</code> 中:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">switch</span> (selectStrategy.calculateStrategy(selectNowSupplier, hasTasks())) &#123;</span><br><span class="line">                <span class="keyword">case</span> SelectStrategy.CONTINUE:</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">case</span> SelectStrategy.SELECT:</span><br><span class="line">                    select(wakenUp.getAndSet(<span class="keyword">false</span>));</span><br><span class="line"></span><br><span class="line">                    </span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">// 省略后续操作...</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            handleLoopException(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 省略后续操作...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>run()</code> 方法中通过监听事件, 在循环中 <strong>针对IO和非IO时间做了不同的处理</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Netty笔记第二部分&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java NIO笔记</title>
    <link href="http://yoursite.com/2018/02/21/nio-notes/"/>
    <id>http://yoursite.com/2018/02/21/nio-notes/</id>
    <published>2018-02-21T12:03:59.000Z</published>
    <updated>2018-02-22T13:37:35.117Z</updated>
    
    <content type="html"><![CDATA[<p>基本的Java NIO笔记, 为学习Netty做准备</p><a id="more"></a><h2 id="四种IO模型"><a href="#四种IO模型" class="headerlink" title="四种IO模型"></a>四种IO模型</h2><p>主流的IO模型主要有如下四种</p><ol><li><p>同步阻塞 (Blocking IO)</p><blockquote><p>即标准的JavaIO实现, 进行IO操作时会阻塞当前线程</p></blockquote></li><li><p>同步非阻塞 (Non-Blocking IO)</p><blockquote><p>同步非阻塞IO即在同步阻塞的基础之上将socket设置为NONBLOCK,这样用户线程在发起IO操作之后可以立即返回,<br>但是用户线程需要不断轮询来请求数据</p></blockquote></li><li><p>IO多路复用 (IO Multiplexing)</p><p><strong>目前不是很明白这个解释, 将来再做整理</strong></p><blockquote><p>多路复用模型从流程上和同步阻塞的区别不大, 主要区别在于操作系统为用户提供了同时轮询多个IO句柄来查看是否有IO事件的接口,<br>从根本上允许用户可以使用单个线程来管理多个IO句柄的问题</p></blockquote></li><li><p>异步IO (Asynchronous IO)</p><blockquote><p>不再需要用户去轮询IO事件, 当事件就绪时内核会开启一个独立的线程去执行IO操作<br>此时用户线程可以直接读取内核线程准备好的数据</p></blockquote></li></ol><h2 id="Java中的NIO"><a href="#Java中的NIO" class="headerlink" title="Java中的NIO"></a>Java中的NIO</h2><p>Java中的NIO实现主要通过 <code>Channel</code>, <code>Selector</code>, <code>Buffer</code> 这三个核心组件</p><h3 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h3><p>多路复用器, 可以将多个 <code>Channel</code> 注册到 <code>Selector</code> 上, 每次注册时将返回一个<br><code>SelectionKey</code>, 代表注册的一个token, <code>SelectionKey</code> 由 <code>Selector</code> 维护, <code>Selector</code><br>包含三个 <code>SelectionKey</code> 的集合</p><ol><li><p>key set</p><blockquote><p>即所有向Selector注册的Channel的令牌信息</p></blockquote></li><li><p>selected key set</p><blockquote><p>当有Channel向Selector注册的IO事件就绪的时候并且有select操作时对应的SelectionKey会被放到该集合中</p></blockquote></li><li><p>cancelled-key</p><blockquote><p>当已注册的Channel取消后放到该集合</p></blockquote></li></ol><h3 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h3><p>缓冲区是一个对象, 对数组进行了包装, 提供了对数据的结构化访问，而且还可以跟踪系统的读/写进程</p><h4 id="状态变量"><a href="#状态变量" class="headerlink" title="状态变量"></a>状态变量</h4><ul><li><p>position</p><p>  追踪已经已经从缓冲区中读取/写入的值</p></li><li><p>limit</p><p>  表明还有多少数据需要取出(在从缓冲区写入通道时)，或者还有多少空间可以放入数据(在从通道读入缓冲区时)</p></li><li><p>capacity</p><p>  可以储存在缓冲区中的最大数据容量</p></li></ul><p><strong>关系: position总是小于等于limit, 而limit不能大于capacity</strong></p><h4 id="flip方法"><a href="#flip方法" class="headerlink" title="flip方法"></a>flip方法</h4><p>由于缓冲区可以支持读写操作, <code>flip()</code> 方法通过修改状态变量的值来变更读/写模式</p><h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><p><code>Channel</code> 是一个对象, 通过它读取或者写入数据, 就像标准IO中的流一样</p><p>在网络IO方面由 <em>ServerSocketChannel</em> 和 <em>SocketChannel</em> 实现, 分别表示服务端和客户端</p><h4 id="服务端ServerSocketChannel的一般流程"><a href="#服务端ServerSocketChannel的一般流程" class="headerlink" title="服务端ServerSocketChannel的一般流程"></a>服务端ServerSocketChannel的一般流程</h4><ol><li>获取一个ServerSocketChannel</li><li>设置网络操作，这些参数主要是和TCP协议有关</li><li>将ServerSocketChannel注册到Selector（多路复用器）</li><li>将ServerSocketChannel和某个具体的地址绑定</li><li>用户向多路复用器设置感兴趣的IO事件</li><li>用户线程以阻塞或非阻塞方式轮询Selector来查看是否有就绪的IO事件</li><li>用户针对不同的IO事件对Channel进行具体的IO操作</li></ol><h4 id="客户端SocketChannel的一般流程"><a href="#客户端SocketChannel的一般流程" class="headerlink" title="客户端SocketChannel的一般流程"></a>客户端SocketChannel的一般流程</h4><ol><li>获取一个SocketChannel</li><li>设置Channel为非阻塞方式</li><li>获取Selector</li><li>将channel注册到Selector，并监听CONNECT事件</li><li>调用channel的connect方法连接指定的服务器和端口</li><li>如果连接成功则进行IO操作，如果没成功则轮询Selector处理CONNECT事件</li></ol><p>服务端代码示例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOEchoServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ByteBuffer BUFFER = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Selector selector;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">NIOEchoServer</span><span class="params">(<span class="keyword">int</span> port)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 打开一个selector</span></span><br><span class="line">    <span class="keyword">this</span>.selector = Selector.open();</span><br><span class="line">    <span class="comment">// 打开一个socket channel</span></span><br><span class="line">    ServerSocketChannel serverChannel = ServerSocketChannel.open();</span><br><span class="line">    <span class="comment">// 设置为非阻塞</span></span><br><span class="line">    serverChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">    <span class="comment">// 获取一个socketServer</span></span><br><span class="line">    ServerSocket serverSocket = serverChannel.socket();</span><br><span class="line">    <span class="comment">// 绑定端口</span></span><br><span class="line">    serverSocket.bind(<span class="keyword">new</span> InetSocketAddress(port));</span><br><span class="line">    <span class="comment">// 绑定channel到selector上</span></span><br><span class="line">    <span class="comment">// 将serverChannel注册到selector上并监听accept事件</span></span><br><span class="line">    <span class="comment">// 该事件在有客户端连接时被触发</span></span><br><span class="line">    serverChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">    System.out.println(String.format(<span class="string">"server start at %d"</span>, port));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    SocketChannel client;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">      <span class="comment">// 阻塞直到有事件到来</span></span><br><span class="line">      <span class="comment">// num 表示监听到的事件总数</span></span><br><span class="line">      <span class="keyword">int</span> num = selector.select();</span><br><span class="line">      <span class="comment">// 响应的事件集合</span></span><br><span class="line">      Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">      Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line">      <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        SelectionKey key = iterator.next();</span><br><span class="line">        <span class="comment">// 响应连接事件</span></span><br><span class="line">        <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">          <span class="comment">// 接受连接请求</span></span><br><span class="line">          client = ((ServerSocketChannel) key.channel()).accept();</span><br><span class="line">          System.out.println(String.format(<span class="string">"accept from %s"</span>, client.getRemoteAddress()));</span><br><span class="line">          <span class="comment">// 异步处理</span></span><br><span class="line">          client.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">          <span class="comment">// 关键代码, 将该Channel注册到selector, 并且监听读事件</span></span><br><span class="line">          client.register(selector, SelectionKey.OP_READ);</span><br><span class="line">          <span class="comment">// 移除原来的selectionKey</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">          <span class="comment">// 响应读事件</span></span><br><span class="line">          SocketChannel sc = (SocketChannel) key.channel();</span><br><span class="line">          <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            BUFFER.clear();</span><br><span class="line">            <span class="keyword">if</span> (sc.read(BUFFER) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            String message = <span class="keyword">new</span> String(BUFFER.array(), Charset.defaultCharset())</span><br><span class="line">                .trim();</span><br><span class="line">            System.out.println(message);</span><br><span class="line">            BUFFER.flip();</span><br><span class="line">            sc.write(BUFFER);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理完毕后从迭代器中移除</span></span><br><span class="line">        iterator.remove();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> NIOEchoServer(<span class="number">8080</span>).listen();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOEchoClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Selector selector;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String sendMessage = <span class="string">"hello world\r\n"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> ByteBuffer readBuffer = ByteBuffer.allocate(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">NIOEchoClient</span><span class="params">(<span class="keyword">int</span> port)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个selector</span></span><br><span class="line">    <span class="keyword">this</span>.selector = Selector.open();</span><br><span class="line">    <span class="comment">// 打开一个客户端channel</span></span><br><span class="line">    SocketChannel clientChannel = SocketChannel.open();</span><br><span class="line">    <span class="comment">// 设置为非阻塞模式</span></span><br><span class="line">    clientChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">    <span class="comment">// 尝试连接端口</span></span><br><span class="line">    clientChannel.connect(<span class="keyword">new</span> InetSocketAddress(port));</span><br><span class="line">    <span class="comment">// 注册并监听连接和读取事件</span></span><br><span class="line">    clientChannel.register(selector, SelectionKey.OP_CONNECT);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">    SocketChannel channel;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">      <span class="comment">// 轮询监听</span></span><br><span class="line">      selector.select();</span><br><span class="line">      Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">      Iterator&lt;SelectionKey&gt; iterator = keys.iterator();</span><br><span class="line">      <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        SelectionKey key = iterator.next();</span><br><span class="line">        <span class="comment">// 因为这个selector中没有注册其他channel</span></span><br><span class="line">        <span class="comment">// 所以这个channel其实就是之前注册的clientChannel</span></span><br><span class="line">        channel = (SocketChannel) key.channel();</span><br><span class="line">        <span class="keyword">if</span> (key.isConnectable()) &#123;</span><br><span class="line">          <span class="comment">// 完成连接</span></span><br><span class="line">          System.out.println(String.format(<span class="string">"connect to %s"</span>, channel.getRemoteAddress()));</span><br><span class="line">          channel.finishConnect();</span><br><span class="line">          key.interestOps(OP_WRITE);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line">          <span class="comment">// 每隔两秒往服务器发送一条消息</span></span><br><span class="line">          TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">          channel.write(ByteBuffer.wrap(sendMessage.getBytes()));</span><br><span class="line">          <span class="comment">// 重新设置感兴趣的事件为读事件, 从服务器读取回显消息</span></span><br><span class="line">          key.interestOps(OP_READ);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">          readBuffer.clear();</span><br><span class="line">          channel.read(readBuffer);</span><br><span class="line">          System.out.println(</span><br><span class="line">              <span class="string">"echo from server: "</span> + <span class="keyword">new</span> String(readBuffer.array(), Charset.defaultCharset())</span><br><span class="line">                  .trim());</span><br><span class="line">          <span class="comment">// 重新设置感兴趣的事件为写事件, 可以继续写入消息</span></span><br><span class="line">          key.interestOps(OP_WRITE);</span><br><span class="line">        &#125;</span><br><span class="line">        iterator.remove();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> NIOEchoClient(<span class="number">8080</span>).send();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p><a href="https://my.oschina.net/andylucc/blog/614295" target="_blank" rel="noopener">Netty精粹之JAVA NIO开发需要知道的</a></p></li><li><p><a href="https://www.ibm.com/developerworks/java/tutorials/j-nio/j-nio.html" target="_blank" rel="noopener">Getting started with new I/O (NIO)</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;基本的Java NIO笔记, 为学习Netty做准备&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Netty笔记 (一)</title>
    <link href="http://yoursite.com/2018/02/20/netty-notes/"/>
    <id>http://yoursite.com/2018/02/20/netty-notes/</id>
    <published>2018-02-20T12:53:31.000Z</published>
    <updated>2018-02-23T02:48:44.912Z</updated>
    
    <content type="html"><![CDATA[<p>学习了Java原生的NIO实现后阅读 《Netty In Action》的读书笔记<br>主要包括Netty中的各个组件</p><a id="more"></a><h2 id="Channel接口"><a href="#Channel接口" class="headerlink" title="Channel接口"></a>Channel接口</h2><p>个人理解Netty中的Channel接口应该是对Java原生Api中的Socket封装, 因为它不仅提供了NIO的channel实现,<br>也提供了OIO的实现, 所以跟原生NIO中的Channel因该不是一个概念</p><h2 id="EventLoop接口"><a href="#EventLoop接口" class="headerlink" title="EventLoop接口"></a>EventLoop接口</h2><p>EventLoop 是Netty的核心抽象, 用于处理连接的生命周期中发生的事情, 一下是EventLoop跟Channel及<br>EventLoopGroup的关系图</p><p><img src="/images/eventloop.png" alt="EventLoop"></p><h2 id="ChannelHandler接口"><a href="#ChannelHandler接口" class="headerlink" title="ChannelHandler接口"></a>ChannelHandler接口</h2><p>主要通过继承/复写ChannelHandler来实现自定义的入站, 出站逻辑</p><p>ChannelHandler有两个重要的子接口实现, ChannelInboundHandler和ChannelOutboundHandler,<br>他们分别作为程序中数据的入站和出站的抽象</p><h2 id="ChannelPipeline接口"><a href="#ChannelPipeline接口" class="headerlink" title="ChannelPipeline接口"></a>ChannelPipeline接口</h2><p>ChannelPipeline主要作为ChannelHandler的 <strong>链式容器</strong> , 即将多个ChannelHandler通过pipeline链接到一起</p><p>当ChannelHandler被添加到ChannelPipeline后会分配一个上下文对象ChannelHandlerContext, 通过它可以进行socket的读写操作</p><h2 id="BootStrap引导"><a href="#BootStrap引导" class="headerlink" title="BootStrap引导"></a>BootStrap引导</h2><p>BootStrap引导类主要是为网络层配置提供容器, 主要需要注意的是服务端使用 <code>ServerBootstrap</code>,<br>而客户端使用 <code>BootStrap</code> 类, 有点类似Socket中的 <code>ServerSocket</code> 和 <code>Socket</code> 的区别</p><p>因为服务端需要绑定(bind)端口, 而客户端则是连接(connect)服务端打开的端口, 所有有不同的实现</p><p>第二点区别是服务器通常会有两个EventLoopGroup(也可以只使用一个), 因为服务器不同于客户端, 它需要面向对个连接,<br>第一个EventLoopGroup监听端口, 并将接收到的连接交给第二个EventLoopGroup处理, 第二个EventLoopGroup则会为它分配<br>一个EventLoop来处理</p><p><img src="/images/eventloopgroup.png" alt="eventloopgroup"></p><h2 id="Echo-Server示例代码"><a href="#Echo-Server示例代码" class="headerlink" title="Echo Server示例代码:"></a>Echo Server示例代码:</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 入站handler</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ChannelInboundHandlerAdapter adapter;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">NettyServer</span><span class="params">(<span class="keyword">int</span> port, ChannelInboundHandlerAdapter adapter)</span> </span>&#123;</span><br><span class="line">    checkNotNull(adapter, <span class="string">"adapter can't be null"</span>);</span><br><span class="line">    <span class="keyword">this</span>.port = port;</span><br><span class="line">    <span class="keyword">this</span>.adapter = adapter;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    EventLoopGroup boosGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">    EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">      <span class="comment">// 设置两个group</span></span><br><span class="line">      b.group(boosGroup, workerGroup)</span><br><span class="line">          .channel(NioServerSocketChannel.class)</span><br><span class="line">          .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> </span>&#123;</span><br><span class="line">              <span class="comment">// 将自己实现的ChannelHandler添加到链式容器中</span></span><br><span class="line">              <span class="comment">// 该方法初始化后会将自己从容器中移除</span></span><br><span class="line">              ch.pipeline().addLast(adapter);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">          .option(ChannelOption.SO_BACKLOG, <span class="number">128</span>)</span><br><span class="line">          .childOption(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">      ChannelFuture f = b.bind(port).sync();</span><br><span class="line">      f.channel().closeFuture().sync();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      boosGroup.shutdownGracefully().sync();</span><br><span class="line">      workerGroup.shutdownGracefully().sync();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> NettyServer(<span class="number">8080</span>, <span class="keyword">new</span> EchoServerHandler()).run();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Sharable</span></span><br><span class="line"><span class="comment">// 通过Sharable注解标注的表示该handler可以重用</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EchoServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ByteBuf buf = (ByteBuf) msg;</span><br><span class="line">    System.out.print(<span class="string">"receive: "</span> + (buf.toString(Charset.defaultCharset())));</span><br><span class="line">    ctx.write(buf);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ctx.writeAndFlush(Unpooled.EMPTY_BUFFER)</span><br><span class="line">        <span class="comment">// 添加关闭的监听器, 以便连接断开时关闭</span></span><br><span class="line">        .addListener(ChannelFutureListener.CLOSE);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    cause.printStackTrace();</span><br><span class="line">    ctx.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Echo-Client示例代码"><a href="#Echo-Client示例代码" class="headerlink" title="Echo Client示例代码:"></a>Echo Client示例代码:</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">NettyClient</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.port = port;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Bootstrap b = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">      <span class="comment">// 客户端只需一个goup</span></span><br><span class="line">      b.group(group)</span><br><span class="line">          .channel(NioSocketChannel.class)</span><br><span class="line">          .remoteAddress(<span class="keyword">new</span> InetSocketAddress(port))</span><br><span class="line">          .handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> </span>&#123;</span><br><span class="line">              ch.pipeline().addLast(<span class="keyword">new</span> EchoClientHandler());</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">      ChannelFuture f = b.connect().sync();</span><br><span class="line">      f.channel().closeFuture().sync();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      group.shutdownGracefully().sync();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> NettyClient(<span class="number">8080</span>).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EchoClientHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">ByteBuf</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 建立连接成功后向服务器发送消息</span></span><br><span class="line">    ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">"hello world"</span>, Charset.defaultCharset()));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, ByteBuf msg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 回显服务器echo回来的消息</span></span><br><span class="line">    System.out.println(<span class="string">"Client Received: "</span> + msg.toString(Charset.defaultCharset()));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> </span>&#123;</span><br><span class="line">    cause.printStackTrace();</span><br><span class="line">    ctx.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习了Java原生的NIO实现后阅读 《Netty In Action》的读书笔记&lt;br&gt;主要包括Netty中的各个组件&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Netty" scheme="http://yoursite.com/tags/Netty/"/>
    
      <category term="NIO" scheme="http://yoursite.com/tags/NIO/"/>
    
  </entry>
  
  <entry>
    <title>并发编程笔记 (二)</title>
    <link href="http://yoursite.com/2018/02/19/concurrency-notes-2/"/>
    <id>http://yoursite.com/2018/02/19/concurrency-notes-2/</id>
    <published>2018-02-19T11:10:50.000Z</published>
    <updated>2018-02-23T02:19:09.338Z</updated>
    
    <content type="html"><![CDATA[<p>《Java并发编程实战》阅读笔记, 主要包括死锁, 显式锁等高级主题</p><a id="more"></a><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p><strong>如果线程以固定顺序获得锁那么程序中就不会出现死锁</strong></p><p>但是有可能因为参数的动态传递而导致原本以为顺序的锁变成非顺序</p><p><strong>避免锁嵌套</strong>, 如果要使用则要确保嵌套锁的执行时序, 或者通过 <code>System.identityHashCode</code><br>动态决定锁的顺序</p><p>需要警惕在持有锁的情况下调用外部方法, 因为该方法可能也是同步的, 会获得两个锁而导致可能的死锁</p><h3 id="开放调用"><a href="#开放调用" class="headerlink" title="开放调用"></a>开放调用</h3><p>调用某个方法时不需要持有锁则被成为开放调用</p><p>也就是尽量缩小同步代码块, 使得锁只保护需要保护的区域</p><h2 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h2><p>多个相互协作的线程都对彼此作出响应而修改自己的状态, 导致任何线程都无法继续执行</p><h2 id="降低锁竞争的方式"><a href="#降低锁竞争的方式" class="headerlink" title="降低锁竞争的方式"></a>降低锁竞争的方式</h2><ul><li>减少锁的持有时间</li><li>降低锁的请求频率</li><li>使用带有协调机制的独占锁</li></ul><h2 id="锁分段"><a href="#锁分段" class="headerlink" title="锁分段"></a>锁分段</h2><p>如果一个锁需要保护多个相互独立的状态变量, 则可以将这个锁分解为多个锁, 并且每个锁只保护一个变量</p><h2 id="显式锁"><a href="#显式锁" class="headerlink" title="显式锁"></a>显式锁</h2><p>显式锁可以解决一些内置锁无法解决的问题, 如</p><ul><li>中断一个正在等待锁的线程</li><li>请求锁时无限等待</li></ul><p>Lock接口的标准使用形式:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="定时锁与轮询锁"><a href="#定时锁与轮询锁" class="headerlink" title="定时锁与轮询锁"></a>定时锁与轮询锁</h3><p>通过 <code>lock.tryLock</code> 来获取锁, 可以防止死锁的发生 (如果在指定时间内无法获得锁将返回一个失败状态)</p><h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p>  允许多个读操作同时执行, 但每次只允许一个写操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ReadWriteLock</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the lock used for reading.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the lock used for reading</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Lock <span class="title">readLock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the lock used for writing.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the lock used for writing</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Lock <span class="title">writeLock</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子: 用读写锁包装的map</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLockMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;K, V&gt; innerMap;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ReadWriteLock lock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Lock rLock = lock.readLock();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Lock wLock = lock.writeLock();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ReadWriteLockMap</span><span class="params">(Map&lt;K, V&gt; innerMap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.innerMap = innerMap;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    rLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> innerMap.size();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      rLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    rLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> innerMap.get(key);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      rLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    wLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> innerMap.put(key, value);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      wLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ........</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《Java并发编程实战》阅读笔记, 主要包括死锁, 显式锁等高级主题&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Concurrency" scheme="http://yoursite.com/tags/Concurrency/"/>
    
  </entry>
  
  <entry>
    <title>Firefox Developer&#39;s Edition 使用小记</title>
    <link href="http://yoursite.com/2018/02/17/firefox-de-hardware-acceleration/"/>
    <id>http://yoursite.com/2018/02/17/firefox-de-hardware-acceleration/</id>
    <published>2018-02-17T10:53:17.000Z</published>
    <updated>2018-02-22T13:30:46.972Z</updated>
    
    <content type="html"><![CDATA[<p>记录一些火狐开发者版本使用中遇到的问题</p><a id="more"></a><h2 id="修改DPI适应高分屏"><a href="#修改DPI适应高分屏" class="headerlink" title="修改DPI适应高分屏"></a>修改DPI适应高分屏</h2><p><em>about:config</em> 中修改 <code>layout.css.devPixelsPerPx</code></p><h2 id="解决画面撕裂"><a href="#解决画面撕裂" class="headerlink" title="解决画面撕裂"></a>解决画面撕裂</h2><p><em>about:config</em> 中修改 <code>layers.acceleration.force-enabled</code> 开启硬件加速</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p><a href="https://cialu.net/enable-hardware-acceleration-firefox-make-faster/" target="_blank" rel="noopener">Enable hardware acceleration in Firefox</a></p></li><li><p><a href="https://fedoramagazine.org/how-to-get-firefox-looking-right-on-a-high-dpi-display-and-fedora/" target="_blank" rel="noopener">How to get Firefox looking right on a high DPI display and Fedora</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录一些火狐开发者版本使用中遇到的问题&lt;/p&gt;
    
    </summary>
    
    
      <category term="firefox" scheme="http://yoursite.com/tags/firefox/"/>
    
      <category term="tools" scheme="http://yoursite.com/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>并发编程笔记 (一)</title>
    <link href="http://yoursite.com/2018/02/14/concurrency-notes/"/>
    <id>http://yoursite.com/2018/02/14/concurrency-notes/</id>
    <published>2018-02-14T14:45:33.000Z</published>
    <updated>2018-02-22T13:35:21.540Z</updated>
    
    <content type="html"><![CDATA[<p>《Java并发编程实战》阅读笔记 (一), 包括基础知识及例子</p><a id="more"></a><h2 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h2><p>增强了同步同步容器类, </p><h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><ul><li>在迭代时不需要加锁</li><li>具有若一致性, 而不是即时失败</li></ul><h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h3><ul><li>安全读取, 写入时复制<ul><li>保留一个指向底层基础数组的索引, 它不会被修改, 因此其他线程可以安全迭代</li></ul></li></ul><h2 id="处理InterruptedException"><a href="#处理InterruptedException" class="headerlink" title="处理InterruptedException"></a>处理InterruptedException</h2><p>抛出该异常表示该方法可能长时间阻塞</p><ul><li>向调用层抛出</li><li>调用 <code>Thread.currentThread().interrput()</code> 中断当前线程</li></ul><h2 id="闭锁"><a href="#闭锁" class="headerlink" title="闭锁"></a>闭锁</h2><p>用于控制多个线程在同一时间点做某件事情, <code>awati()</code> 方法调用后直到该 <code>countDownLatch</code> 值<br>为1, 否则一直阻塞</p><h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>信号量管理一组 <strong>许可</strong>, 执行操作时首先通过 <code>acquire()</code> 获取许可, 执行完后再通过 <code>release()</code><br>返回许可, 当没有许可时 <code>acquire()</code> 会阻塞或抛出异常</p><p><strong>例子: 通过信号量实现有界容器</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoundedSet</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;T&gt; innerSet;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Semaphore sem;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">BoundedSet</span><span class="params">(<span class="keyword">int</span> bound)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 封装为同步容器, 多个线程会添加或删除</span></span><br><span class="line">    <span class="keyword">this</span>.innerSet = Collections.synchronizedSet(<span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">    <span class="keyword">this</span>.sem = <span class="keyword">new</span> Semaphore(bound);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(T t)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 添加时若容器已满则阻塞</span></span><br><span class="line">    sem.acquire();</span><br><span class="line">    <span class="keyword">return</span> innerSet.add(t);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> removed = innerSet.remove(t);</span><br><span class="line">    <span class="keyword">if</span> (removed) &#123;</span><br><span class="line">      <span class="comment">// 删除时若删除成功则返回许可</span></span><br><span class="line">      sem.release();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> removed;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 测试, 先充满容器, 再添加元素时应该阻塞, 两秒后删除某个元素后</span></span><br><span class="line">    <span class="comment">// 应该可以继续正常添加</span></span><br><span class="line">    <span class="keyword">int</span> bound = <span class="number">10</span>;</span><br><span class="line">    BoundedSet&lt;Integer&gt; boundedSet = <span class="keyword">new</span> BoundedSet&lt;&gt;(bound);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">      boundedSet.add(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      boundedSet.remove(<span class="number">8</span>);</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"start adding 11"</span>);</span><br><span class="line">    boundedSet.add(<span class="number">10</span>);</span><br><span class="line">    System.out.println(<span class="string">"this should appear after 2 seconds"</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="栅栏barrier"><a href="#栅栏barrier" class="headerlink" title="栅栏barrier"></a>栅栏barrier</h2><p>可以确保在并行计算中, 每个线程都执行完第K步操作后才进入第K+1步</p><h3 id="与闭锁的区别"><a href="#与闭锁的区别" class="headerlink" title="与闭锁的区别"></a>与闭锁的区别</h3><p>所有线程必须同时到 <strong>栅栏的位置</strong> 才可以继续运行<br>这个 <strong>位置</strong> 可以由线程自己调用</p><h2 id="Memorzer缓存实例"><a href="#Memorzer缓存实例" class="headerlink" title="Memorzer缓存实例"></a>Memorzer缓存实例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Memoizer</span>&lt;<span class="title">A</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Computable</span>&lt;<span class="title">A</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;A, Future&lt;V&gt;&gt; cache</span><br><span class="line">      = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Computable&lt;A, V&gt; c;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Memoizer</span><span class="params">(Computable&lt;A, V&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.c = c;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> V <span class="title">compute</span><span class="params">(A a)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">      Future&lt;V&gt; f = cache.get(a);</span><br><span class="line">      <span class="comment">// 缓存中没有值</span></span><br><span class="line">      <span class="keyword">if</span> (f == <span class="keyword">null</span>) &#123;</span><br><span class="line">        FutureTask&lt;V&gt; ft = <span class="keyword">new</span> FutureTask&lt;&gt;(() -&gt; c.compute(a));</span><br><span class="line">        <span class="comment">// 这时其他线程可能已经放入了future</span></span><br><span class="line">        f = cache.putIfAbsent(a, ft);</span><br><span class="line">        <span class="comment">// 如果已经有future了则不替换 (putIfAbsent是原子操作)</span></span><br><span class="line">        <span class="keyword">if</span> (f == <span class="keyword">null</span>) &#123;</span><br><span class="line">          f = ft;</span><br><span class="line">          <span class="comment">// 否则运行future</span></span><br><span class="line">          <span class="comment">// 可保证future只运行一次</span></span><br><span class="line">          ft.run();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 只要有线程在计算则会阻塞 (因为不会被替换)</span></span><br><span class="line">        <span class="keyword">return</span> f.get();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CompletionService"><a href="#CompletionService" class="headerlink" title="CompletionService"></a>CompletionService</h2><p>将 <em>Executor</em> 与 <em>BlockingQueue</em> 结合到一起, 可以通过 <code>take()</code> 异步获取已经完成的任务</p><h2 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h2><p>调用中断不意味着立即停止, 而只是发起了停止请求， 在适当的时候执行中断, 并做好清理工作</p><p>可以通过 <code>Thread.currentThread.isInterrupted</code> 方法判断当前线程是否已经收到了中断请求</p><h3 id="响应中断"><a href="#响应中断" class="headerlink" title="响应中断"></a>响应中断</h3><p>有两种策略可以用于处理 <code>InterruptedException</code></p><ol><li>抛出中断异常</li><li><strong>恢复</strong> 中断状态, 使得上层代码可以处理中断</li></ol><p>关于第二中方式, 刚看书的时候并不明白什么叫 <em>恢复中断</em>,<br>查了一下找到了这篇<a href="https://stackoverflow.com/questions/4906799/why-invoke-thread-currentthread-interrupt-in-a-catch-interruptexception-block" target="_blank" rel="noopener">解释</a></p><p>在捕获 <code>InterruptedException</code> 后会清除当前的中断状态, 所以外部线程无法看到该线程是否中断,<br>因此才需要调用<code>Thread.currentThread().interrupt()</code> 来重新设置线程的中断状态, 从而使外部线程可以处理</p><p><strong>如下面这个例子</strong></p><p>如果在异常捕获后没有设置当前线程的 <code>interrupt</code>,<br>那么在一次中断后当前线程在调用 <code>sleep</code> 或者 <code>take</code><br>这样的阻塞方法时仍然会继续阻塞, 因为它们看不到当前线程的已阻塞标志</p><p>而手动调用 <code>Thread.currentThread.isInterrupted</code> 后在下次循环时 <code>sleep</code> 或者<br><code>take</code> 方法可以看到该线程已经中断, 因此会直接再次抛出中断异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueInterruptTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> BlockingQueue&lt;Integer&gt; QUEUE</span><br><span class="line">      = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 该线程会在take或sleep处阻塞直到外部调用中断</span></span><br><span class="line">    Thread t = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          System.out.println(<span class="string">"ignore sleep interrupt"</span>);</span><br><span class="line">          <span class="comment">// 不显式调用该方法则下次循环到该处还会继续阻塞</span></span><br><span class="line">          <span class="comment">// 因为sleep看不到该线程已被中断</span></span><br><span class="line">          <span class="comment">// Thread.currentThread().interrupt();</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"still looping..."</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          QUEUE.take();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          System.out.println(<span class="string">"take interrupt"</span>);</span><br><span class="line">          <span class="comment">// Thread.currentThread().interrupt();</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    t.start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动一个线程10秒后中断BlockingQueue的线程</span></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(<span class="string">"interrupt t, status: "</span> + t.isInterrupted());</span><br><span class="line">      t.interrupt();</span><br><span class="line">    &#125;).start();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="处理不可中断的阻塞"><a href="#处理不可中断的阻塞" class="headerlink" title="处理不可中断的阻塞"></a>处理不可中断的阻塞</h3><p>以下几种阻塞操作不会抛出 <code>interruptexception</code>, 因此需要手动调用相关的方法关闭阻塞操作,<br>可以复写线程的 <code>interrput</code> 方法在响应中断时进行相应的处理</p><ul><li>同步/异步 IO 手动调用关闭IO</li><li>获取某个锁而阻塞 通过 <code>lockInterruptibly</code> 中断锁等待</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《Java并发编程实战》阅读笔记 (一), 包括基础知识及例子&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Concurrency" scheme="http://yoursite.com/tags/Concurrency/"/>
    
  </entry>
  
  <entry>
    <title>VIM中的Operator-Pending</title>
    <link href="http://yoursite.com/2018/02/04/vim-operator-pending-md/"/>
    <id>http://yoursite.com/2018/02/04/vim-operator-pending-md/</id>
    <published>2018-02-04T08:37:17.000Z</published>
    <updated>2018-02-22T13:37:51.844Z</updated>
    
    <content type="html"><![CDATA[<p>VIM已经用了有一年了, 但是这一年来基本上只是用到了最基本的功能, 并没有提高很多自己的码字效率,<br>插件倒是装了一堆却并没有理解为什么,<br>使用着强大的工具却不了解其运作原理总归让人有点不安, 所以趁这两天准备把VIM的基本运作方式搞搞清楚, 顺便给自己的 <em>.vimrc</em> 瘦个身。</p><a id="more"></a><p>首先, 看的是在线版本的 <a href="&#39;http://learnvimscriptthehardway.stevelosh.com/&#39;">Learn Vim The Hard Way</a></p><p>前几章关于 <em>基本设置</em> , <em>文件类型相关设置</em> , <em>按键映射</em> 方面的章节都还好, 到 <a href="&#39;http://learnvimscriptthehardway.stevelosh.com/chapters/15.html&#39;">operator-padding</a><br>这一章就有点看不懂了, 主要是因为 <em>text-objects</em> 有些不明白, 因此又看了另一篇 <a href="&#39;https://blog.carbonfive.com/2011/10/17/vim-text-objects-the-definitive-guide/&#39;">博客</a>,<br>搞懂了 <em>text-objects</em> 之后再来看就简单多了。</p><h2 id="Text-Objects"><a href="#Text-Objects" class="headerlink" title="Text-Objects"></a>Text-Objects</h2><p>VIM中的 <em>text-objects</em> 是更高效得操作单词、句子、段落的一个作用域对象, 称为 <strong>文本对象</strong></p><p>首先需要了解VIM的命令结构</p><p>VIM中的命令结构如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;number&gt;&lt;command&gt;&lt;text object or motion&gt;</span><br></pre></td></tr></table></figure><ul><li><p><strong>number</strong> 是指作用的文本对象数量, 它是可选的, 并且可以在之前或者之后出现</p></li><li><p><strong>commond</strong> 对文本对象的操作, 如删除、复制等, 它也是可选的, 但如果不指定则该命令就<br>失去了编辑能力</p></li><li><p><strong>text objects or motion</strong> 指文本对象的作用域, 如一个单词(w), 一句话(s), 或一个段落(p)</p></li></ul><p>总的来说 一个命令由以上几部分组成起来, 就可以将基本的修改、移动操作变得更加强大</p><h3 id="文本对象类型"><a href="#文本对象类型" class="headerlink" title="文本对象类型"></a>文本对象类型</h3><p>以下为一些常用的文本对象类型</p><ul><li>iw inner word</li><li>aw a word</li><li>iW inner WORD</li><li>aW a WORD</li><li>is inner sentence</li><li>as a sentence</li><li>ip inner paragraph</li><li>ap a paragraph</li><li>it inner tag</li><li>at a tag</li><li>i  ( or i) inner block</li><li>a  ( or a) a block</li><li>i  &lt; or i&gt; inner block</li><li>a  &lt; or a&gt; a block</li><li>i  { or i} inner block</li><li>a  { or a} a block</li><li>i  [ or i] inner block</li><li>a  [ or a] a block</li><li>i  inner block</li><li>a  a block</li><li>i` inner block</li><li>a` a block</li></ul><p>从列表中可以看出, <em>text objects</em> 不仅可以匹配单词句子, 还可以匹配到括号等变成中经常会用到的<br>符号, 数量使用的话会相当方便</p><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><h4 id="普通文本"><a href="#普通文本" class="headerlink" title="普通文本"></a>普通文本</h4><p><code>diw</code> 或 <code>daw</code> 删除当前选中的单词</p><p>其中 <em>d</em> 指 <strong>commond</strong> , 而 <em>iw</em> 则是一个单词类型的文本对象</p><p>注意 <code>diw</code> 只会删除单词, 而 <code>daw</code> 会同时删除单词旁边的空格, 这是因为</p><p><em>iw</em> 表示 <em>inner word</em> 而 <em>aw</em> 表示 <em>a word</em> , 它不仅会选中单词, 还会选中旁边的空格</p><h4 id="程序文本"><a href="#程序文本" class="headerlink" title="程序文本"></a>程序文本</h4><p>如下 <em>html</em> 代码中, 使用 <code>cit</code> 命令可以快速修改两个tag之间的内容</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>hello world!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Operator-Pending"><a href="#Operator-Pending" class="headerlink" title="Operator-Pending"></a>Operator-Pending</h2><p><em>Operator-Pending</em> 中的Operaotr就是上文中的 <strong>commond</strong>,<br>配上 <em>text-object</em> 或者一个 <em>movement</em> 就构成了一个完成的命令</p><h3 id="Movement-映射"><a href="#Movement-映射" class="headerlink" title="Movement 映射"></a>Movement 映射</h3><p>VIM 允许将命令中的 <em>movement</em> 映射到其他按键, 如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:onoremap p i(</span><br></pre></td></tr></table></figure><p>将 <code>i(&#39;</code> 映射到按键p上, 也就是说 <code>dp</code> 等价于 <code>di(</code>, 即删除括号中的内容</p><p>第二个例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:onoremap b /return&lt;cr&gt;</span><br></pre></td></tr></table></figure><p>执行 <code>db</code>, VIM会删除所有下一个 <code>return</code> 之间的内容</p><p>第三个例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:onoremap in( :&lt;c-u&gt;normal! f(vi(&lt;cr&gt;</span><br></pre></td></tr></table></figure><p>执行 <code>din(</code> 会删除当前光标所在的后一对 () 中的内容, 其中用到了 <em>normal!</em><br>来模拟命令, 关键点就是 <code>f(</code> 这个命令移动到最近的 <code>(</code> 然后通过 <code>vi(</code> 选中下一个 <code>)</code><br>之间的内容</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;VIM已经用了有一年了, 但是这一年来基本上只是用到了最基本的功能, 并没有提高很多自己的码字效率,&lt;br&gt;插件倒是装了一堆却并没有理解为什么,&lt;br&gt;使用着强大的工具却不了解其运作原理总归让人有点不安, 所以趁这两天准备把VIM的基本运作方式搞搞清楚, 顺便给自己的 &lt;em&gt;.vimrc&lt;/em&gt; 瘦个身。&lt;/p&gt;
    
    </summary>
    
    
      <category term="vim" scheme="http://yoursite.com/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>mysql笔记 (一)</title>
    <link href="http://yoursite.com/2018/02/01/mysql_notes_1/"/>
    <id>http://yoursite.com/2018/02/01/mysql_notes_1/</id>
    <published>2018-02-01T14:59:05.000Z</published>
    <updated>2018-02-22T13:35:37.034Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="#%E5%B1%82%E7%BA%A7%E7%BB%93%E6%9E%84">层级结构</a></li><li><a href="#%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E">存储引擎</a><ul><li><a href="#myisam">MyISAM</a><ul><li><a href="#%E7%B4%A2%E5%BC%95%E6%94%AF%E6%8C%81">索引支持</a></li></ul></li><li><a href="#innodb">InnoDB</a><ul><li><a href="#%E4%B8%BB%E8%A6%81%E7%89%B9%E6%80%A7">主要特性</a></li></ul></li></ul></li><li><a href="#%E6%9D%83%E9%99%90%E7%BA%A7%E5%88%AB">权限级别</a><ul><li><a href="#global-level">Global Level</a></li><li><a href="#database-level">Database Level</a></li><li><a href="#tabel-level">Tabel Level</a></li><li><a href="#column-level">Column Level</a></li><li><a href="#routine-level">Routine Level</a></li><li><a href="#grant">GRANT</a></li></ul></li></ul><a id="more"></a><h1 id="层级结构"><a href="#层级结构" class="headerlink" title="层级结构"></a>层级结构</h1><p><strong>Sql Layer</strong> 负责查询相关, <strong>Storage Engine Layer</strong> 底层数据存储相关</p><p>将存储与计算分离</p><p><img src="/images/mysql_layer.png" alt="mysql_layer.png"></p><h1 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h1><h2 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h2><h3 id="索引支持"><a href="#索引支持" class="headerlink" title="索引支持"></a>索引支持</h3><ol><li>B-Tree<ul><li>按照 <em>B-Tree</em> 结构存储数据</li></ul></li><li>R-Tree<ul><li>设计用于为存储空间和多维数据的字段做索引 (暂时不是很明白这段话的意思)</li></ul></li><li>Full-Text<ul><li>全文检索, 提高 <em>LIKE</em> 查询的效率</li></ul></li></ol><h2 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h2><h3 id="主要特性"><a href="#主要特性" class="headerlink" title="主要特性"></a>主要特性</h3><ol><li>支持事务安全</li><li>数据多版本读取</li><li>锁定机制改进<ul><li>改变了MyISAM的锁机制实现了行锁</li></ul></li><li>实现外建</li></ol><h1 id="权限级别"><a href="#权限级别" class="headerlink" title="权限级别"></a>权限级别</h1><h2 id="Global-Level"><a href="#Global-Level" class="headerlink" title="Global Level"></a>Global Level</h2><p>全局级别, <strong>拥有最高优先级</strong></p><p><code>*.*</code> 表示全局作用域</p><p>示例:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span>,<span class="keyword">UPDATE</span>,<span class="keyword">DELETE</span>,<span class="keyword">INSERT</span> <span class="keyword">ON</span> *.* <span class="keyword">TO</span> <span class="string">'def'</span>@<span class="string">'localhost'</span>;</span><br></pre></td></tr></table></figure><h2 id="Database-Level"><a href="#Database-Level" class="headerlink" title="Database Level"></a>Database Level</h2><p><code>database.*</code> 表示数据库级别作用域</p><p>示例:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALTER</span> <span class="keyword">ON</span> test.* <span class="keyword">TO</span> <span class="string">'def'</span>@<span class="string">'localhost'</span>;</span><br></pre></td></tr></table></figure><p>也可以先选定数据库, 然后通过 <code>*</code> 来限定作用域为当前数据库, 如:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">USE</span> <span class="keyword">test</span>;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">DROP</span> <span class="keyword">ON</span> * <span class="keyword">TO</span> <span class="string">'def'</span>@<span class="string">'localhost'</span>;</span><br></pre></td></tr></table></figure><p>多个用户可以用逗号隔开:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">CREATE</span> <span class="keyword">ON</span> perf.* <span class="keyword">TO</span> <span class="string">'abc'</span>@<span class="string">'localhost'</span>,<span class="string">'def'</span>@<span class="string">'localhost'</span>;</span><br></pre></td></tr></table></figure><h2 id="Tabel-Level"><a href="#Tabel-Level" class="headerlink" title="Tabel Level"></a>Tabel Level</h2><p><code>database.table</code> 表级别作用域</p><p>示例:</p><p>其中 <em>%</em> 表示通配符</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">INDEX</span> <span class="keyword">ON</span> test.t1 <span class="keyword">TO</span> <span class="string">'abc'</span>@<span class="string">'%.jianzhaoyang.com'</span>;</span><br></pre></td></tr></table></figure><h2 id="Column-Level"><a href="#Column-Level" class="headerlink" title="Column Level"></a>Column Level</h2><p>列级别, 语法与 <em>Table Level</em> 相似, 只是需要在括号中指定列</p><p>示例:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span>(<span class="keyword">id</span>,<span class="keyword">value</span>) <span class="keyword">ON</span> test.t2 <span class="keyword">TO</span> <span class="string">'abc'</span>@<span class="string">'%.jianzhaoyang.com'</span>;</span><br></pre></td></tr></table></figure><h2 id="Routine-Level"><a href="#Routine-Level" class="headerlink" title="Routine Level"></a>Routine Level</h2><p>主要针对 <em>procedure</em> 和 <em>function</em></p><h2 id="GRANT"><a href="#GRANT" class="headerlink" title="GRANT"></a>GRANT</h2><p>特殊权限, 拥有该权限的用户可以将 <strong>自身</strong> 拥有的权限赋予其他用户</p><p>示例:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> ALL <span class="keyword">ON</span> test.t5 <span class="keyword">TO</span> <span class="string">'abc'</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%B1%82%E7%BA%A7%E7%BB%93%E6%9E%84&quot;&gt;层级结构&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E&quot;&gt;存储引擎&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#myisam&quot;&gt;MyISAM&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E7%B4%A2%E5%BC%95%E6%94%AF%E6%8C%81&quot;&gt;索引支持&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#innodb&quot;&gt;InnoDB&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E4%B8%BB%E8%A6%81%E7%89%B9%E6%80%A7&quot;&gt;主要特性&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%9D%83%E9%99%90%E7%BA%A7%E5%88%AB&quot;&gt;权限级别&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#global-level&quot;&gt;Global Level&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#database-level&quot;&gt;Database Level&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#tabel-level&quot;&gt;Tabel Level&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#column-level&quot;&gt;Column Level&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#routine-level&quot;&gt;Routine Level&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#grant&quot;&gt;GRANT&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
</feed>
